Iteration 16
Timestamp: 2025-07-12 16:31:27
==================================================

CODE:
# filename: boids_simulation.py
"""
Boids++ Simulation System with Spatial Hash Grid Optimization, Multiple Agent Types,
Advanced Flocking Behaviors, Predator-Prey Interaction, Obstacle Avoidance,
Performance Optimization, Configuration Support, and Pygame Visualization.

Implements:
- SpatialHashGrid for efficient neighbor queries
- Agent classes: Boid, Predator, Obstacle, Leader
- Weighted steering and state machines for adaptive AI
- Real-time interactive controls
- Auto test mode with accelerated simulation and detailed performance reporting
- ScoreManager for feature scoring and recommendations

Author: Expert Python Developer
Date: 2024-06
"""

import sys
import os
import json
import math
import time
import threading
import logging
import argparse
from collections import defaultdict, deque
from dataclasses import dataclass, field
from typing import List, Tuple, Dict, Optional, Union, Callable, Any

import pygame
import numpy as np

# Constants for colors
WHITE = (255, 255, 255)
GREY = (100, 100, 100)
BLACK = (0, 0, 0)
RED = (220, 50, 50)
GREEN = (50, 220, 50)
BLUE = (50, 50, 220)
YELLOW = (220, 220, 50)
CYAN = (50, 220, 220)
MAGENTA = (220, 50, 220)
ORANGE = (255, 165, 0)

# Logger setup
LOG_FILENAME = 'boids_simulation.log'
logging.basicConfig(
    filename=LOG_FILENAME,
    filemode='a',
    format='%(asctime)s %(levelname)s %(message)s',
    level=logging.INFO
)

# Custom exceptions
class FeatureTestError(Exception):
    pass

class PerformanceError(Exception):
    pass

class OptimizationRequiredError(Exception):
    pass

# Utility functions
def limit_vector(vector: np.ndarray, max_value: float) -> np.ndarray:
    norm = np.linalg.norm(vector)
    if norm > max_value:
        return vector / norm * max_value
    return vector

def angle_to_vector(angle: float) -> np.ndarray:
    return np.array([math.cos(angle), math.sin(angle)], dtype=np.float32)

def vector_to_angle(vector: np.ndarray) -> float:
    return math.atan2(vector[1], vector[0])

def clamp(value: float, min_value: float, max_value: float) -> float:
    return max(min_value, min(value, max_value))

def distance_sq(a: np.ndarray, b: np.ndarray) -> float:
    return np.sum((a - b) ** 2)

# Configuration System
class Config:
    """
    Loads and provides access to simulation configuration parameters.
    Supports external JSON config file and presets.
    """
    defaultConfigPath = "config.json"
    presets: Dict[str, Dict[str, Any]] = {
        "default": {
            "windowWidth": 1024,
            "windowHeight": 768,
            "gridCellSize": 50,
            "boidCount": 150,
            "predatorCount": 5,
            "obstacleCount": 20,
            "leaderCount": 2,
            "maxSpeedBoid": 3.5,
            "maxForceBoid": 0.05,
            "maxSpeedPredator": 4.5,
            "maxForcePredator": 0.07,
            "perceptionRadius": 75,
            "separationRadius": 25,
            "obstacleAvoidanceRadius": 40,
            "boundaryMargin": 50,
            "fpsTarget": 60,
            "speedMultiplier": 1.0,
            "visualizeGrid": False,
            "visualizeVectors": False,
            "maxAgents": 300,
            "autoTestSpeedMultiplier": 5.0,
            "autoTestDuration": 30.0,
            "autoTestPhases": [
                {"name": "flocking", "duration": 10},
                {"name": "predator_prey", "duration": 10},
                {"name": "obstacle_avoidance", "duration": 10}
            ]
        }
    }

    def __init__(self, preset_name: str = "default", config_file: Optional[str] = None):
        self.config: Dict[str, Any] = {}
        self.load_preset(preset_name)
        if config_file:
            self.load_file(config_file)

    def load_preset(self, preset_name: str) -> None:
        preset = self.presets.get(preset_name)
        if preset is None:
            raise ValueError(f"Preset '{preset_name}' not found.")
        self.config.update(preset)

    def load_file(self, filepath: str) -> None:
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.config.update(data)
        except Exception as e:
            logging.error(f"Failed to load config from {filepath}: {e}")

    def __getitem__(self, key: str) -> Any:
        return self.config[key]

    def get(self, key: str, default: Any = None) -> Any:
        return self.config.get(key, default)

    def set(self, key: str, value: Any) -> None:
        self.config[key] = value

# Spatial Hash Grid System
class SpatialHashGrid:
    """
    Efficient spatial hash grid for neighbor queries.
    Assigns agents to grid cells based on position.
    """

    def __init__(self, width: int, height: int, cellSize: int):
        self.width = width
        self.height = height
        self.cellSize = cellSize
        self.grid: Dict[Tuple[int, int], List['Agent']] = defaultdict(list)

    def _hash(self, position: np.ndarray) -> Tuple[int, int]:
        return (int(position[0]) // self.cellSize, int(position[1]) // self.cellSize)

    def clear(self) -> None:
        self.grid.clear()

    def insert(self, agent: 'Agent') -> None:
        cell = self._hash(agent.position)
        self.grid[cell].append(agent)

    def query(self, position: np.ndarray, radius: float) -> List['Agent']:
        # Determine affected cells
        cellX, cellY = self._hash(position)
        cellRadius = int(math.ceil(radius / self.cellSize))
        neighbors = []
        for dx in range(-cellRadius, cellRadius + 1):
            for dy in range(-cellRadius, cellRadius + 1):
                cell = (cellX + dx, cellY + dy)
                if cell in self.grid:
                    neighbors.extend(self.grid[cell])
        return neighbors

    def get_cells(self) -> List[Tuple[int, int]]:
        return list(self.grid.keys())

# Base Agent Class
class Agent:
    """
    Base class for all agents in the simulation.
    """

    def __init__(
        self,
        position: np.ndarray,
        velocity: np.ndarray,
        max_speed: float,
        max_force: float,
        agent_type: str,
        radius: float = 5.0,
        color: Tuple[int, int, int] = WHITE,
        config: Optional[Config] = None,
    ):
        self.position = position.astype(np.float32)
        self.velocity = velocity.astype(np.float32)
        self.acceleration = np.zeros(2, dtype=np.float32)
        self.maxSpeed = max_speed
        self.maxForce = max_force
        self.agentType = agent_type
        self.radius = radius
        self.color = color
        self.config = config
        self.state = 'normal'  # for predators and other stateful agents
        self.id = id(self)  # unique id for debugging

    def applyForce(self, force: np.ndarray) -> None:
        self.acceleration += force

    def update(self, dt: float) -> None:
        self.velocity += self.acceleration
        self.velocity = limit_vector(self.velocity, self.maxSpeed)
        self.position += self.velocity * dt
        self.acceleration *= 0

    def edges(self, width: int, height: int) -> None:
        margin = self.config.get('boundaryMargin', 50) if self.config else 50
        bounce = False
        if self.position[0] < margin:
            self.position[0] = margin
            self.velocity[0] *= -1
            bounce = True
        elif self.position[0] > width - margin:
            self.position[0] = width - margin
            self.velocity[0] *= -1
            bounce = True

        if self.position[1] < margin:
            self.position[1] = margin
            self.velocity[1] *= -1
            bounce = True
        elif self.position[1] > height - margin:
            self.position[1] = height - margin
            self.velocity[1] *= -1
            bounce = True

        if bounce:
            self.velocity = limit_vector(self.velocity, self.maxSpeed)

    def draw(self, surface: pygame.Surface) -> None:
        # Draw as triangle pointing in velocity direction
        angle = vector_to_angle(self.velocity)
        points = []
        size = self.radius
        # Triangle shape
        points.append(
            (
                self.position[0] + math.cos(angle) * size * 2,
                self.position[1] + math.sin(angle) * size * 2,
            )
        )
        points.append(
            (
                self.position[0] + math.cos(angle + 2.5) * size,
                self.position[1] + math.sin(angle + 2.5) * size,
            )
        )
        points.append(
            (
                self.position[0] + math.cos(angle - 2.5) * size,
                self.position[1] + math.sin(angle - 2.5) * size,
            )
        )
        pygame.draw.polygon(surface, self.color, points)

# Derived Agent Types
class Boid(Agent):
    """
    Standard Boid agent with flocking behavior.
    """

    def __init__(self, position: np.ndarray, velocity: np.ndarray, config: Config):
        super().__init__(
            position,
            velocity,
            max_speed=config['maxSpeedBoid'],
            max_force=config['maxForceBoid'],
            agent_type='boid',
            radius=5,
            color=BLUE,
            config=config,
        )
        self.perceptionRadius = config['perceptionRadius']
        self.separationRadius = config['separationRadius']
        self.obstacleAvoidanceRadius = config['obstacleAvoidanceRadius']
        self.neighbors: List[Agent] = []

    def flock(
        self,
        neighbors: List['Agent'],
        obstacles: List['Agent'],
        predators: List['Agent'],
        dt: float,
        width: int,
        height: int,
    ) -> None:
        # Weighted steering behaviors combined
        separation = self.separation(neighbors)
        alignment = self.alignment(neighbors)
        cohesion = self.cohesion(neighbors)
        avoidance = self.avoidObstacles(obstacles)
        evade = self.evadePredators(predators)

        # Weights
        wSeparation = 1.8
        wAlignment = 1.0
        wCohesion = 1.0
        wAvoidance = 2.0
        wEvade = 2.5

        steer = (
            separation * wSeparation
            + alignment * wAlignment
            + cohesion * wCohesion
            + avoidance * wAvoidance
            + evade * wEvade
        )
        if np.any(np.isnan(steer)):
            steer = np.zeros(2, dtype=np.float32)
        self.applyForce(steer)
        self.edges(width, height)

    def separation(self, neighbors: List['Agent']) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        total = 0
        for other in neighbors:
            if other is self or other.agentType == 'obstacle':
                continue
            d = np.linalg.norm(self.position - other.position)
            if 0 < d < self.separationRadius:
                diff = self.position - other.position
                if d > 0:
                    diff /= d
                steer += diff
                total += 1
        if total > 0:
            steer /= total
            steer = limit_vector(steer, self.maxForce)
        return steer

    def alignment(self, neighbors: List['Agent']) -> np.ndarray:
        avg_vel = np.zeros(2, dtype=np.float32)
        total = 0
        for other in neighbors:
            if other is self or other.agentType == 'obstacle':
                continue
            d = np.linalg.norm(self.position - other.position)
            if 0 < d < self.perceptionRadius:
                avg_vel += other.velocity
                total += 1
        if total > 0:
            avg_vel /= total
            avg_vel = limit_vector(avg_vel, self.maxSpeed)
            steer = avg_vel - self.velocity
            steer = limit_vector(steer, self.maxForce)
            return steer
        return np.zeros(2, dtype=np.float32)

    def cohesion(self, neighbors: List['Agent']) -> np.ndarray:
        center_of_mass = np.zeros(2, dtype=np.float32)
        total = 0
        for other in neighbors:
            if other is self or other.agentType == 'obstacle':
                continue
            d = np.linalg.norm(self.position - other.position)
            if 0 < d < self.perceptionRadius:
                center_of_mass += other.position
                total += 1
        if total > 0:
            center_of_mass /= total
            desired = center_of_mass - self.position
            desired = limit_vector(desired, self.maxSpeed)
            steer = desired - self.velocity
            steer = limit_vector(steer, self.maxForce)
            return steer
        return np.zeros(2, dtype=np.float32)

    def avoidObstacles(self, obstacles: List['Agent']) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        total = 0
        for obs in obstacles:
            d = np.linalg.norm(self.position - obs.position)
            if d < self.obstacleAvoidanceRadius + obs.radius:
                diff = self.position - obs.position
                if d > 0:
                    diff /= (d * d)  # stronger repulsion closer
                steer += diff
                total += 1
        if total > 0:
            steer /= total
            steer = limit_vector(steer, self.maxForce)
        return steer

    def evadePredators(self, predators: List['Agent']) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        total = 0
        for pred in predators:
            d = np.linalg.norm(self.position - pred.position)
            if d < self.perceptionRadius * 1.5:
                diff = self.position - pred.position
                if d > 0:
                    diff /= (d * d)
                steer += diff
                total += 1
        if total > 0:
            steer /= total
            steer = limit_vector(steer, self.maxForce * 1.5)
        return steer

class Predator(Agent):
    """
    Predator agent with chase and wander behaviors.
    """

    def __init__(self, position: np.ndarray, velocity: np.ndarray, config: Config):
        super().__init__(
            position,
            velocity,
            max_speed=config['maxSpeedPredator'],
            max_force=config['maxForcePredator'],
            agent_type='predator',
            radius=8,
            color=RED,
            config=config,
        )
        self.perceptionRadius = config['perceptionRadius'] * 1.5
        self.target: Optional[Agent] = None
        self.state = 'hunt'
        self.wanderAngle = 0.0

    def chase(self, boids: List[Agent], dt: float) -> None:
        # Find closest boid within perception
        min_dist = float('inf')
        closest = None
        for boid in boids:
            d = np.linalg.norm(self.position - boid.position)
            if d < min_dist and d < self.perceptionRadius:
                min_dist = d
                closest = boid
        self.target = closest
        if self.target is not None:
            desired = self.target.position - self.position
            desired = limit_vector(desired, self.maxSpeed)
            steer = desired - self.velocity
            steer = limit_vector(steer, self.maxForce * 1.5)
            self.applyForce(steer)
        else:
            self.wander(dt)
        self.edges(self.config['windowWidth'], self.config['windowHeight'])

    def wander(self, dt: float) -> None:
        wanderRadius = 10.0
        wanderDistance = 20.0
        change = 0.3
        self.wanderAngle += (np.random.rand() - 0.5) * change

        circlePos = self.velocity.copy()
        if np.linalg.norm(circlePos) == 0:
            circlePos = np.array([1.0, 0.0], dtype=np.float32)
        circlePos = circlePos / np.linalg.norm(circlePos) * wanderDistance + self.position

        offset = np.array(
            [math.cos(self.wanderAngle), math.sin(self.wanderAngle)], dtype=np.float32
        ) * wanderRadius

        target = circlePos + offset
        desired = target - self.position
        desired = limit_vector(desired, self.maxSpeed)
        steer = desired - self.velocity
        steer = limit_vector(steer, self.maxForce)
        self.applyForce(steer)

    def update(self, dt: float) -> None:
        super().update(dt)

class Obstacle(Agent):
    """
    Static obstacle agent.
    """

    def __init__(self, position: np.ndarray, radius: float, config: Config):
        super().__init__(
            position,
            velocity=np.zeros(2, dtype=np.float32),
            max_speed=0,
            max_force=0,
            agent_type='obstacle',
            radius=radius,
            color=GREY,
            config=config,
        )

    def update(self, dt: float) -> None:
        # Static obstacle: no update needed
        pass

    def draw(self, surface: pygame.Surface) -> None:
        pygame.draw.circle(surface, self.color, self.position.astype(int), int(self.radius))

class Leader(Boid):
    """
    Leader boid that influences nearby boids.
    """

    def __init__(self, position: np.ndarray, velocity: np.ndarray, config: Config):
        super().__init__(position, velocity, config)
        self.color = ORANGE
        self.radius = 7
        self.leaderInfluenceRadius = config['perceptionRadius'] * 1.2

    def lead(self, neighbors: List['Agent']) -> None:
        # Apply stronger cohesion force to neighbors
        cohesionForce = self.cohesion(neighbors)
        self.applyForce(cohesionForce * 1.5)

# Score Manager for feature evaluation
class ScoreManager:
    """
    Manages scoring of simulation features with detailed breakdown.
    """

    def __init__(self):
        self.featureScores = {
            "flocking_behavior": 0,
            "spatial_hash_efficiency": 0,
            "obstacle_avoidance": 0,
            "predator_prey_interactions": 0,
            "ui_and_controls": 0,
            "performance_optimization": 0,
            "code_quality": 0,
            "documentation": 0,
            "error_handling": 0,
            "testing": 0,
        }
        self.totalScore = 0
        self.recommendations = []

    def set_score(self, feature: str, score: int) -> None:
        if feature in self.featureScores:
            self.featureScores[feature] = score
        else:
            logging.warning(f"Unknown feature for scoring: {feature}")

    def calculate_total(self) -> None:
        self.totalScore = sum(self.featureScores.values())

    def add_recommendation(self, text: str) -> None:
        self.recommendations.append(text)

    def output_report(self) -> None:
        self.calculate_total()
        print(f"BOIDS_SIMULATION_SCORE: {self.totalScore}/100\n")
        print("Score Breakdown:")
        for feature, score in self.featureScores.items():
            print(f"- {feature.replace('_', ' ').capitalize()}: {score}/"
                  f"{self._max_score_for_feature(feature)}")
        print("\nRecommendations:")
        if not self.recommendations:
            print("- None. Great job!")
        else:
            for rec in self.recommendations:
                print(f"- {rec}")

    def _max_score_for_feature(self, feature: str) -> int:
        weights = {
            "flocking_behavior": 20,
            "spatial_hash_efficiency": 15,
            "obstacle_avoidance": 10,
            "predator_prey_interactions": 10,
            "ui_and_controls": 10,
            "performance_optimization": 15,
            "code_quality": 10,
            "documentation": 5,
            "error_handling": 5,
            "testing": 5,
        }
        return weights.get(feature, 0)

# Main Simulation Class
class BoidsSimulation:
    """
    Main Boids++ Simulation system.
    Handles initialization, update loops, rendering, input, and testing.
    """

    def __init__(self, config: Config, auto_test_mode: bool = False):
        pygame.init()
        self.config = config
        self.width = config['windowWidth']
        self.height = config['windowHeight']
        self.screen = pygame.display.set_mode((self.width, self.height))
        pygame.display.set_caption("Boids++ Simulation")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont("Consolas", 16)
        self.largeFont = pygame.font.SysFont("Consolas", 28, bold=True)

        # Spatial grid for neighbor queries
        self.grid = SpatialHashGrid(
            self.width, self.height, self.config['gridCellSize']
        )

        # Agents lists
        self.boids: List[Boid] = []
        self.predators: List[Predator] = []
        self.obstacles: List[Obstacle] = []
        self.leaders: List[Leader] = []

        # Parameters
        self.speedMultiplier = config.get('speedMultiplier', 1.0)
        self.visualizeGrid = config.get('visualizeGrid', False)
        self.visualizeVectors = config.get('visualizeVectors', False)
        self.running = True
        self.paused = False

        # Counters
        self.frameCount = 0
        self.fps = 0.0
        self.lastFpsUpdate = time.time()

        # Score Manager
        self.scoreManager = ScoreManager()

        # Auto-test related
        self.autoTestMode = auto_test_mode
        self.autoTestStartTime = None
        self.autoTestPhaseIndex = 0
        self.autoTestPhaseStartTime = None

        # For performance monitoring
        self.fpsHistory = deque(maxlen=120)

        self._setup_agents()

        # Controls mapping
        self.controlHelp = [
            "SPACE: Pause/Resume simulation",
            "UP/DOWN: Increase/Decrease speed multiplier",
            "G: Toggle grid visualization",
            "V: Toggle vector visualization",
            "ESC: Quit",
        ]

    def _setup_agents(self) -> None:
        # Clear all agents
        self.boids.clear()
        self.predators.clear()
        self.obstacles.clear()
        self.leaders.clear()

        # Create obstacles
        obstacleCount = self.config.get('obstacleCount', 20)
        for _ in range(obstacleCount):
            pos = np.array(
                [np.random.uniform(50, self.width - 50), np.random.uniform(50, self.height - 50)],
                dtype=np.float32,
            )
            radius = np.random.uniform(10, 20)
            self.obstacles.append(Obstacle(pos, radius, self.config))

        # Create leaders
        leaderCount = self.config.get('leaderCount', 2)
        for _ in range(leaderCount):
            pos = np.array(
                [np.random.uniform(50, self.width - 50), np.random.uniform(50, self.height - 50)],
                dtype=np.float32,
            )
            vel = np.random.uniform(-1, 1, 2)
            self.leaders.append(Leader(pos, vel, self.config))

        # Create boids
        boidCount = self.config.get('boidCount', 150)
        for _ in range(boidCount):
            pos = np.array(
                [np.random.uniform(50, self.width - 50), np.random.uniform(50, self.height - 50)],
                dtype=np.float32,
            )
            vel = np.random.uniform(-1, 1, 2)
            self.boids.append(Boid(pos, vel, self.config))

        # Create predators
        predatorCount = self.config.get('predatorCount', 5)
        for _ in range(predatorCount):
            pos = np.array(
                [np.random.uniform(50, self.width - 50), np.random.uniform(50, self.height - 50)],
                dtype=np.float32,
            )
            vel = np.random.uniform(-1, 1, 2)
            self.predators.append(Predator(pos, vel, self.config))

    def run(self) -> None:
        if self.autoTestMode:
            self.autoTestStartTime = time.time()
            self.autoTestPhaseStartTime = self.autoTestStartTime
            self.speedMultiplier = self.config.get('autoTestSpeedMultiplier', 5.0)
            self._run_auto_test()
        else:
            self._run_normal()

    def _run_normal(self) -> None:
        while self.running:
            dt = self.clock.tick(self.config['fpsTarget']) / 1000.0 * self.speedMultiplier
            self._handle_events()
            if not self.paused:
                self._update(dt)
            self._render()
            self._update_fps()
            self.frameCount += 1

    def _run_auto_test(self) -> None:
        """
        Runs the 30-second accelerated testing:
        0-10s: flocking behavior
        10-20s: predator-prey
        20-30s: obstacle avoidance
        """
        phases = self.config.get('autoTestPhases', [])
        phaseDurations = [p['duration'] for p in phases]
        phaseNames = [p['name'] for p in phases]
        totalDuration = sum(phaseDurations)
        self.running = True

        while self.running:
            now = time.time()
            elapsed = now - self.autoTestStartTime
            if elapsed >= totalDuration:
                self.running = False
                break

            # Determine current phase
            phaseTime = elapsed
            currentPhaseIndex = 0
            cumulative = 0
            for i, dur in enumerate(phaseDurations):
                cumulative += dur
                if phaseTime < cumulative:
                    currentPhaseIndex = i
                    break

            if currentPhaseIndex != self.autoTestPhaseIndex:
                self.autoTestPhaseIndex = currentPhaseIndex
                self.autoTestPhaseStartTime = now
                print(f"[AutoTest] Switched to phase: {phaseNames[currentPhaseIndex]}")

                # Reset agents for phase
                if phaseNames[currentPhaseIndex] == 'flocking':
                    self._setup_agents()
                elif phaseNames[currentPhaseIndex] == 'predator_prey':
                    self._setup_agents()
                elif phaseNames[currentPhaseIndex] == 'obstacle_avoidance':
                    self._setup_agents()

            dt = self.clock.tick(self.config['fpsTarget'] * self.speedMultiplier) / 1000.0
            self._handle_events(auto_test=True)
            self._update(dt, testPhase=phaseNames[currentPhaseIndex])
            self._render(auto_test=True)
            self._update_fps()
            self.frameCount += 1

            # Print progress every 5 seconds
            if int(elapsed) % 5 == 0 and int(elapsed) != int(elapsed - dt):
                print(f"[AutoTest] Progress: {int(elapsed)} / {int(totalDuration)} sec, FPS: {self.fps:.1f}")

        print("BOIDS_SIMULATION_COMPLETE_SUCCESS")
        self.scoreManager.output_report()
        pygame.quit()
        sys.exit(0)

    def _handle_events(self, auto_test: bool = False) -> None:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False
                if not auto_test:
                    if event.key == pygame.K_SPACE:
                        self.paused = not self.paused
                    elif event.key == pygame.K_UP:
                        self.speedMultiplier = min(10.0, self.speedMultiplier + 0.1)
                    elif event.key == pygame.K_DOWN:
                        self.speedMultiplier = max(0.1, self.speedMultiplier - 0.1)
                    elif event.key == pygame.K_g:
                        self.visualizeGrid = not self.visualizeGrid
                    elif event.key == pygame.K_v:
                        self.visualizeVectors = not self.visualizeVectors

    def _update(self, dt: float, testPhase: Optional[str] = None) -> None:
        # Clear spatial grid and reinsert all agents
        self.grid.clear()
        allAgents = self.boids + self.predators + self.obstacles + self.leaders
        for agent in allAgents:
            self.grid.insert(agent)

        # Update Boids
        for boid in self.boids:
            neighbors = self.grid.query(boid.position, boid.perceptionRadius)
            obstacles = [o for o in self.obstacles if np.linalg.norm(boid.position - o.position) < boid.obstacleAvoidanceRadius + o.radius]
            predators = [p for p in self.predators if np.linalg.norm(boid.position - p.position) < boid.perceptionRadius * 1.5]

            # Leaders influence nearby boids
            leadersNearby = [l for l in self.leaders if np.linalg.norm(boid.position - l.position) < l.leaderInfluenceRadius]

            boid.flock(neighbors, obstacles, predators, dt, self.width, self.height)
            # Additional leader influence
            for leader in leadersNearby:
                leaderCohesion = leader.cohesion(neighbors)
                boid.applyForce(leaderCohesion * 0.7)

            boid.update(dt)

        # Update Leaders (leadership behavior)
        for leader in self.leaders:
            neighbors = self.grid.query(leader.position, leader.leaderInfluenceRadius)
            leader.lead(neighbors)
            leader.update(dt)
            leader.edges(self.width, self.height)

        # Update Predators
        for predator in self.predators:
            predator.chase(self.boids, dt)
            predator.update(dt)

        # Obstacles static, no update

    def _render(self, auto_test: bool = False) -> None:
        self.screen.fill(BLACK)
        # Draw obstacles first
        for obstacle in self.obstacles:
            obstacle.draw(self.screen)
        # Draw boids
        for boid in self.boids:
            boid.draw(self.screen)
            if self.visualizeVectors:
                # Draw velocity vector
                start = boid.position.astype(int)
                end = (boid.position + boid.velocity * 10).astype(int)
                pygame.draw.line(self.screen, CYAN, start, end, 1)

        # Draw leaders
        for leader in self.leaders:
            leader.draw(self.screen)

        # Draw predators
        for predator in self.predators:
            predator.draw(self.screen)
            if self.visualizeVectors:
                start = predator.position.astype(int)
                end = (predator.position + predator.velocity * 12).astype(int)
                pygame.draw.line(self.screen, MAGENTA, start, end, 2)

        # Draw spatial grid if enabled
        if self.visualizeGrid:
            self._draw_grid_overlay()

        # Draw UI
        self._draw_ui(auto_test)

        pygame.display.flip()

    def _draw_grid_overlay(self) -> None:
        cellSize = self.grid.cellSize
        for x in range(0, self.width, cellSize):
            pygame.draw.line(self.screen, GREY, (x, 0), (x, self.height), 1)
        for y in range(0, self.height, cellSize):
            pygame.draw.line(self.screen, GREY, (0, y), (self.width, y), 1)

        # Highlight occupied cells
        for cell in self.grid.get_cells():
            rect = pygame.Rect(cell[0] * cellSize, cell[1] * cellSize, cellSize, cellSize)
            pygame.draw.rect(self.screen, (120, 120, 120, 80), rect, 1)

    def _draw_ui(self, auto_test: bool) -> None:
        # FPS and agent counts
        fps_text = self.font.render(f"FPS: {self.fps:.1f}", True, WHITE)
        boid_text = self.font.render(f"Boids: {len(self.boids)}", True, BLUE)
        predator_text = self.font.render(f"Predators: {len(self.predators)}", True, RED)
        obstacle_text = self.font.render(f"Obstacles: {len(self.obstacles)}", True, GREY)
        leader_text = self.font.render(f"Leaders: {len(self.leaders)}", True, ORANGE)
        speed_text = self.font.render(f"Speed x{self.speedMultiplier:.1f}", True, YELLOW)
        mode_text = self.font.render(
            f"Mode: {'Auto Test' if auto_test else 'Normal'}", True, GREEN if not auto_test else ORANGE
        )

        self.screen.blit(fps_text, (10, 10))
        self.screen.blit(boid_text, (10, 30))
        self.screen.blit(predator_text, (10, 50))
        self.screen.blit(obstacle_text, (10, 70))
        self.screen.blit(leader_text, (10, 90))
        self.screen.blit(speed_text, (10, 110))
        self.screen.blit(mode_text, (10, 130))

        if not auto_test:
            # Show controls
            y = 150
            for line in self.controlHelp:
                textSurf = self.font.render(line, True, WHITE)
                self.screen.blit(textSurf, (10, y))
                y += 20

        if self.paused:
            pause_text = self.largeFont.render("PAUSED", True, RED)
            self.screen.blit(
                pause_text,
                (
                    self.width // 2 - pause_text.get_width() // 2,
                    self.height // 2 - pause_text.get_height() // 2,
                ),
            )

    def _update_fps(self) -> None:
        now = time.time()
        if now - self.lastFpsUpdate > 0.5:
            self.fps = self.clock.get_fps()
            self.fpsHistory.append(self.fps)
            self.lastFpsUpdate = now
            if self.fps < 30 and not self.autoTestMode:
                logging.warning(f"Low FPS detected: {self.fps:.2f}")
                # Trigger optimization advice
                # Could implement adaptive LOD or agent count reduction here.

# Entry point
def main() -> None:
    parser = argparse.ArgumentParser(description="Boids++ Simulation")
    parser.add_argument('--auto-test', action='store_true', help='Run 30-second auto test mode')
    parser.add_argument('--config', type=str, default=None, help='Path to config JSON file')
    parser.add_argument('--preset', type=str, default='default', help='Simulation preset name')
    args = parser.parse_args()

    config = Config(preset_name=args.preset, config_file=args.config)
    sim = BoidsSimulation(config, auto_test_mode=args.auto_test)
    try:
        sim.run()
    except Exception as e:
        logging.exception(f"Unhandled exception: {e}")
        print(f"Simulation crashed with error: {e}")
        sys.exit(1)
    finally:
        pygame.quit()

if __name__ == "__main__":
    main()

