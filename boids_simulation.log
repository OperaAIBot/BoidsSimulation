Iteration 5
Timestamp: 2025-07-12 15:45:32
==================================================

ERROR MESSAGE:
Traceback (most recent call last):
  File "C:\Users\hyuns\source\repos\AI_Auto_Project\boids_simulation.py", line 904, in <module>
    main()
  File "C:\Users\hyuns\source\repos\AI_Auto_Project\boids_simulation.py", line 901, in main
    sim.run()
  File "C:\Users\hyuns\source\repos\AI_Auto_Project\boids_simulation.py", line 888, in run
    self.draw()
  File "C:\Users\hyuns\source\repos\AI_Auto_Project\boids_simulation.py", line 786, in draw
    agent.draw(self.screen)
  File "C:\Users\hyuns\source\repos\AI_Auto_Project\boids_simulation.py", line 220, in draw
    pygame.draw.polygon(surface, self.color, rotated_points)
TypeError: points must be number pairs


CODE:
# filename: boids_simulation.py
import pygame
import sys
import math
import random
import numpy as np
import time
import threading
import json
import os
from typing import List, Tuple, Dict, Optional
from collections import defaultdict, deque

# Custom Exceptions
class FeatureTestError(Exception):
    pass

class PerformanceError(Exception):
    pass

class OptimizationRequiredError(Exception):
    pass

# Config Management
class ConfigManager:
    """Manages loading and accessing simulation configuration and presets."""
    defaultConfig = {
        "windowWidth": 1200,
        "windowHeight": 800,
        "backgroundColor": [25, 25, 25],
        "gridColor": [50, 50, 50],
        "gridCellSize": 60,
        "maxAgents": 250,
        "boidCount": 180,
        "predatorCount": 10,
        "obstacleCount": 15,
        "leaderCount": 5,
        "maxSpeed": 4.0,
        "maxForce": 0.12,
        "neighborRadius": 60,
        "desiredSeparation": 20,
        "weights": {
            "separation": 1.8,
            "alignment": 1.0,
            "cohesion": 1.0,
            "avoidObstacle": 3.0,
            "predatorAvoidance": 4.0,
            "leaderAttraction": 1.5,
            "boundaryAvoidance": 5.0
        },
        "fpsTarget": 60,
        "speedMultiplier": 1.0,
        "visualizationModes": ["agents", "grid", "stats"],
        "initialVisualizationMode": "agents",
        "autoTestDuration": 30,  # seconds
        "autoTestSpeedMultiplier": 5.0,
        "autoTestSwitchInterval": 10,  # seconds
    }

    def __init__(self, configPath: Optional[str] = None):
        self.config = dict(ConfigManager.defaultConfig)
        if configPath and os.path.isfile(configPath):
            try:
                with open(configPath, "r") as f:
                    externalConfig = json.load(f)
                self.config.update(externalConfig)
            except Exception as e:
                print(f"[ConfigManager] Warning: Failed to load config file {configPath}: {e}")

    def get(self, key: str, default=None):
        return self.config.get(key, default)

    def update(self, key: str, value):
        self.config[key] = value

    def getWeights(self):
        return self.config.get("weights", {})

# Vector helpers using numpy
def limitVector(vec: np.ndarray, maxVal: float) -> np.ndarray:
    norm = np.linalg.norm(vec)
    if norm > maxVal:
        return vec * maxVal / norm
    return vec

def distanceVec(a: np.ndarray, b: np.ndarray) -> float:
    return np.linalg.norm(a - b)

def angleVec(vec: np.ndarray) -> float:
    return math.degrees(math.atan2(vec[1], vec[0])) + 90

# Spatial Hash Grid System
class SpatialHashGrid:
    """Efficient spatial hash grid for neighbor queries and obstacle detection."""
    def __init__(self, width: int, height: int, cellSize: int):
        self.width = width
        self.height = height
        self.cellSize = cellSize
        self.cols = math.ceil(width / cellSize)
        self.rows = math.ceil(height / cellSize)
        self.cells: Dict[Tuple[int, int], List['Agent']] = defaultdict(list)

    def _hash(self, position: np.ndarray) -> Tuple[int, int]:
        col = int(position[0] // self.cellSize)
        row = int(position[1] // self.cellSize)
        return (col, row)

    def clear(self):
        self.cells.clear()

    def addAgent(self, agent: 'Agent'):
        cell = self._hash(agent.position)
        self.cells[cell].append(agent)

    def update(self, agents: List['Agent']):
        self.clear()
        for agent in agents:
            self.addAgent(agent)

    def neighbors(self, agent: 'Agent', radius: float) -> List['Agent']:
        pos = agent.position
        cellX, cellY = self._hash(pos)
        neighbors = []
        radiusCell = max(1, int(math.ceil(radius / self.cellSize)))
        for dx in range(-radiusCell, radiusCell + 1):
            for dy in range(-radiusCell, radiusCell + 1):
                cell = (cellX + dx, cellY + dy)
                if cell in self.cells:
                    for other in self.cells[cell]:
                        if other is agent:
                            continue
                        if np.linalg.norm(other.position - pos) <= radius:
                            neighbors.append(other)
        return neighbors

    def agentsInRadius(self, position: np.ndarray, radius: float) -> List['Agent']:
        cellX, cellY = self._hash(position)
        neighbors = []
        radiusCell = max(1, int(math.ceil(radius / self.cellSize)))
        for dx in range(-radiusCell, radiusCell + 1):
            for dy in range(-radiusCell, radiusCell + 1):
                cell = (cellX + dx, cellY + dy)
                if cell in self.cells:
                    for agent in self.cells[cell]:
                        if np.linalg.norm(agent.position - position) <= radius:
                            neighbors.append(agent)
        return neighbors

    def drawGrid(self, surface: pygame.Surface, color: Tuple[int, int, int]):
        for x in range(0, self.width, self.cellSize):
            pygame.draw.line(surface, color, (x, 0), (x, self.height), 1)
        for y in range(0, self.height, self.cellSize):
            pygame.draw.line(surface, color, (0, y), (self.width, y), 1)

# Abstract Agent Class
class Agent:
    """Base class for any agent in the simulation."""
    def __init__(self,
                 position: np.ndarray,
                 velocity: np.ndarray,
                 config: ConfigManager):
        self.position = position
        self.velocity = velocity
        self.acceleration = np.zeros(2, dtype=np.float32)
        self.config = config
        self.maxSpeed = self.config.get("maxSpeed", 4.0)
        self.maxForce = self.config.get("maxForce", 0.12)
        self.size = 6
        self.color = (255, 255, 255)
        self.type = "agent"
        self.active = True

    def update(self, deltaTime: float):
        """Update position and velocity based on acceleration."""
        self.velocity += self.acceleration * deltaTime
        self.velocity = limitVector(self.velocity, self.maxSpeed)
        self.position += self.velocity * deltaTime
        self.acceleration *= 0  # Reset acceleration

    def applyForce(self, force: np.ndarray):
        self.acceleration += force

    def edges(self, width: int, height: int):
        """Wrap around edges."""
        wrapped = False
        if self.position[0] < 0:
            self.position[0] += width
            wrapped = True
        elif self.position[0] > width:
            self.position[0] -= width
            wrapped = True
        if self.position[1] < 0:
            self.position[1] += height
            wrapped = True
        elif self.position[1] > height:
            self.position[1] -= height
            wrapped = True
        return wrapped

    def draw(self, surface: pygame.Surface):
        """Draw the agent on the surface."""
        # Draw as a triangle pointing in velocity direction
        if np.linalg.norm(self.velocity) < 0.1:
            angle = 0
        else:
            angle = angleVec(self.velocity)
        points = []
        size = self.size
        points.append((0, -size * 2))
        points.append((size, size * 2))
        points.append((-size, size * 2))
        rotated_points = []
        rad = math.radians(angle)
        cos_a = math.cos(rad)
        sin_a = math.sin(rad)
        for x, y in points:
            rx = x * cos_a - y * sin_a
            ry = x * sin_a + y * cos_a
            rotated_points.append((self.position[0] + rx, self.position[1] + ry))
        pygame.draw.polygon(surface, self.color, rotated_points)

# Boid Agent
class Boid(Agent):
    """Standard Boid with flocking behavior."""
    def __init__(self,
                 position: np.ndarray,
                 velocity: np.ndarray,
                 config: ConfigManager):
        super().__init__(position, velocity, config)
        self.type = "boid"
        self.color = (100, 200, 255)
        self.size = 6
        self.weights = self.config.getWeights()
        self.maxSpeed = self.config.get("maxSpeed", 4.0)
        self.maxForce = self.config.get("maxForce", 0.12)

    def flock(self,
              neighbors: List[Agent],
              obstacles: List['Obstacle'],
              predators: List['Predator'],
              leaders: List['Leader'],
              width: int,
              height: int):
        sep = self.separation(neighbors)
        ali = self.alignment(neighbors)
        coh = self.cohesion(neighbors)
        avoid_obs = self.avoidObstacles(obstacles)
        avoid_pred = self.evadePredators(predators)
        follow_leaders = self.followLeaders(leaders)
        boundary_force = self.boundaryAvoidance(width, height)

        # Weighted sum of forces
        force = np.zeros(2, dtype=np.float32)
        force += sep * self.weights.get("separation", 1.8)
        force += ali * self.weights.get("alignment", 1.0)
        force += coh * self.weights.get("cohesion", 1.0)
        force += avoid_obs * self.weights.get("avoidObstacle", 3.0)
        force += avoid_pred * self.weights.get("predatorAvoidance", 4.0)
        force += follow_leaders * self.weights.get("leaderAttraction", 1.5)
        force += boundary_force * self.weights.get("boundaryAvoidance", 5.0)

        force = limitVector(force, self.maxForce)
        self.applyForce(force)

    def separation(self, neighbors: List[Agent]) -> np.ndarray:
        desiredSeparation = self.config.get("desiredSeparation", 20)
        steer = np.zeros(2, dtype=np.float32)
        count = 0
        for other in neighbors:
            d = np.linalg.norm(self.position - other.position)
            if 0 < d < desiredSeparation:
                diff = self.position - other.position
                diff /= d * d  # Weight by inverse square of distance
                steer += diff
                count += 1
        if count > 0:
            steer /= count
        if np.linalg.norm(steer) > 0:
            steer = limitVector(steer, self.maxForce)
        return steer

    def alignment(self, neighbors: List[Agent]) -> np.ndarray:
        neighborDist = self.config.get("neighborRadius", 60)
        sum_vel = np.zeros(2, dtype=np.float32)
        count = 0
        for other in neighbors:
            if isinstance(other, Boid):
                d = np.linalg.norm(self.position - other.position)
                if 0 < d < neighborDist:
                    sum_vel += other.velocity
                    count += 1
        if count > 0:
            sum_vel /= count
            sum_vel = limitVector(sum_vel, self.maxSpeed)
            steer = sum_vel - self.velocity
            steer = limitVector(steer, self.maxForce)
            return steer
        else:
            return np.zeros(2, dtype=np.float32)

    def cohesion(self, neighbors: List[Agent]) -> np.ndarray:
        neighborDist = self.config.get("neighborRadius", 60)
        centerMass = np.zeros(2, dtype=np.float32)
        count = 0
        for other in neighbors:
            if isinstance(other, Boid):
                d = np.linalg.norm(self.position - other.position)
                if 0 < d < neighborDist:
                    centerMass += other.position
                    count += 1
        if count > 0:
            centerMass /= count
            desired = centerMass - self.position
            desired = limitVector(desired, self.maxSpeed)
            steer = desired - self.velocity
            steer = limitVector(steer, self.maxForce)
            return steer
        else:
            return np.zeros(2, dtype=np.float32)

    def avoidObstacles(self, obstacles: List['Obstacle']) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        for obs in obstacles:
            offset = obs.position - self.position
            dist = np.linalg.norm(offset)
            safeDist = obs.radius + self.size + 10
            if dist < safeDist and dist > 0:
                repel = self.position - obs.position
                repel /= dist * dist
                steer += repel
        if np.linalg.norm(steer) > 0:
            steer = limitVector(steer, self.maxForce)
        return steer

    def evadePredators(self, predators: List['Predator']) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        panicDist = 100
        for pred in predators:
            offset = pred.position - self.position
            dist = np.linalg.norm(offset)
            if dist < panicDist and dist > 0:
                flee = self.position - pred.position
                flee /= dist * dist
                steer += flee
        if np.linalg.norm(steer) > 0:
            steer = limitVector(steer, self.maxForce * 2)
        return steer

    def followLeaders(self, leaders: List['Leader']) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        attractDist = 150
        count = 0
        for leader in leaders:
            offset = leader.position - self.position
            dist = np.linalg.norm(offset)
            if dist < attractDist:
                desired = leader.position - self.position
                desired = limitVector(desired, self.maxSpeed)
                steer += desired - self.velocity
                count += 1
        if count > 0:
            steer /= count
            steer = limitVector(steer, self.maxForce)
        return steer

    def boundaryAvoidance(self, width: int, height: int) -> np.ndarray:
        margin = 25
        force = np.zeros(2, dtype=np.float32)
        if self.position[0] < margin:
            force[0] = self.maxForce
        elif self.position[0] > width - margin:
            force[0] = -self.maxForce
        if self.position[1] < margin:
            force[1] = self.maxForce
        elif self.position[1] > height - margin:
            force[1] = -self.maxForce
        return force

# Predator Agent
class Predator(Agent):
    """Predator agent with hunting behavior."""
    def __init__(self,
                 position: np.ndarray,
                 velocity: np.ndarray,
                 config: ConfigManager):
        super().__init__(position, velocity, config)
        self.type = "predator"
        self.color = (255, 60, 60)
        self.size = 10
        self.maxSpeed = self.config.get("maxSpeed", 5.0) * 1.2
        self.maxForce = self.config.get("maxForce", 0.15) * 1.5
        self.huntRadius = 150
        self.state = "search"  # Could be 'search', 'hunt'
        self.target: Optional[Boid] = None

    def update(self, deltaTime: float):
        # Update as normal agent, but with potential state changes
        super().update(deltaTime)

    def hunt(self, boids: List[Boid], grid: SpatialHashGrid, width: int, height: int):
        # Hunting behavior: chase closest boid within huntRadius
        if self.target and not self.target.active:
            self.target = None
            self.state = "search"

        if self.state == "search":
            # Find closest boid
            nearbyBoids = grid.agentsInRadius(self.position, self.huntRadius)
            closestBoid = None
            closestDist = float('inf')
            for boid in nearbyBoids:
                if isinstance(boid, Boid) and boid.active:
                    dist = np.linalg.norm(boid.position - self.position)
                    if dist < closestDist:
                        closestDist = dist
                        closestBoid = boid
            if closestBoid:
                self.target = closestBoid
                self.state = "hunt"
            else:
                # Wander randomly
                wanderForce = np.random.uniform(-1, 1, 2)
                wanderForce = limitVector(wanderForce, self.maxForce)
                self.applyForce(wanderForce)
        elif self.state == "hunt":
            if self.target and self.target.active:
                desired = self.target.position - self.position
                dist = np.linalg.norm(desired)
                if dist < self.size + self.target.size:
                    # Capture prey
                    self.target.active = False
                    self.target = None
                    self.state = "search"
                    # Slight speed burst after capture
                    self.applyForce(-self.velocity * 0.5)
                else:
                    desired = limitVector(desired, self.maxSpeed)
                    steer = desired - self.velocity
                    steer = limitVector(steer, self.maxForce * 2)
                    self.applyForce(steer)
            else:
                self.target = None
                self.state = "search"

        # Boundary forces to keep predators inside
        boundaryForce = self.boundaryAvoidance(width, height)
        self.applyForce(boundaryForce)

    def boundaryAvoidance(self, width: int, height: int) -> np.ndarray:
        margin = 50
        force = np.zeros(2, dtype=np.float32)
        if self.position[0] < margin:
            force[0] = self.maxForce
        elif self.position[0] > width - margin:
            force[0] = -self.maxForce
        if self.position[1] < margin:
            force[1] = self.maxForce
        elif self.position[1] > height - margin:
            force[1] = -self.maxForce
        return force

# Obstacle Agent
class Obstacle(Agent):
    """Static obstacle agent."""
    def __init__(self,
                 position: np.ndarray,
                 radius: float,
                 config: ConfigManager):
        super().__init__(position, np.zeros(2), config)
        self.type = "obstacle"
        self.radius = radius
        self.color = (120, 120, 120)
        self.size = int(radius)

    def update(self, deltaTime: float):
        pass  # Obstacles do not move

    def draw(self, surface: pygame.Surface):
        pygame.draw.circle(surface, self.color, (int(self.position[0]), int(self.position[1])), self.radius)

# Leader Agent
class Leader(Agent):
    """Leader agent that influences boids."""
    def __init__(self,
                 position: np.ndarray,
                 velocity: np.ndarray,
                 config: ConfigManager):
        super().__init__(position, velocity, config)
        self.type = "leader"
        self.color = (255, 255, 100)
        self.size = 8
        self.maxSpeed = self.config.get("maxSpeed", 4.0)
        self.maxForce = self.config.get("maxForce", 0.12)

    def update(self, deltaTime: float):
        # Simple wandering leader
        wanderForce = np.random.uniform(-1, 1, 2)
        wanderForce = limitVector(wanderForce, self.maxForce)
        self.applyForce(wanderForce)
        super().update(deltaTime)
        # Keep inside bounds by bouncing
        self.bounceEdges(self.config.get("windowWidth", 1200), self.config.get("windowHeight", 800))

    def bounceEdges(self, width: int, height: int):
        bounced = False
        if self.position[0] < 0:
            self.position[0] = 0
            self.velocity[0] *= -1
            bounced = True
        elif self.position[0] > width:
            self.position[0] = width
            self.velocity[0] *= -1
            bounced = True
        if self.position[1] < 0:
            self.position[1] = 0
            self.velocity[1] *= -1
            bounced = True
        elif self.position[1] > height:
            self.position[1] = height
            self.velocity[1] *= -1
            bounced = True
        return bounced

# Score Manager for evaluation
class ScoreManager:
    """Manages scoring system for simulation features and performance."""
    def __init__(self):
        self.scores = {
            "flocking": 0,
            "spatialHashEfficiency": 0,
            "obstacleAvoidance": 0,
            "predatorPreyInteractions": 0,
            "uiControls": 0,
            "performanceOptimization": 0,
            "codeQuality": 0,
            "documentation": 0,
            "errorHandling": 0,
            "testing": 0,
        }
        self.weights = {
            "flocking": 20,
            "spatialHashEfficiency": 15,
            "obstacleAvoidance": 10,
            "predatorPreyInteractions": 10,
            "uiControls": 10,
            "performanceOptimization": 15,
            "codeQuality": 10,
            "documentation": 5,
            "errorHandling": 5,
            "testing": 5,
        }

    def setScore(self, feature: str, score: int):
        if feature in self.scores:
            self.scores[feature] = max(0, min(score, self.weights[feature]))

    def calculatePerformanceScore(self, fps: float, agentCount: int):
        # 15-20 points: 60+ FPS with 200+ agents
        # 10-14 points: 45-59 FPS with 200+ agents
        # 5-9 points: 30-44 FPS with 200+ agents
        # 0-4 points: Below 30 FPS with 200+ agents
        if agentCount < 200:
            # Scale down proportionally
            ratio = agentCount / 200
            baseScore = 0
            if fps >= 60:
                baseScore = 20
            elif fps >= 45:
                baseScore = 14
            elif fps >= 30:
                baseScore = 9
            else:
                baseScore = 4
            scaled = int(baseScore * ratio)
            self.setScore("performanceOptimization", scaled)
            return

        if fps >= 60:
            self.setScore("performanceOptimization", 20)
        elif fps >= 45:
            self.setScore("performanceOptimization", 14)
        elif fps >= 30:
            self.setScore("performanceOptimization", 9)
        else:
            self.setScore("performanceOptimization", 4)

    def totalScore(self):
        return sum(self.scores.values())

    def report(self):
        lines = ["\nScore Breakdown:"]
        for feat, weight in self.weights.items():
            score = self.scores.get(feat, 0)
            lines.append(f"- {feat.replace('_', ' ').capitalize()}: {score}/{weight}")
        total = self.totalScore()
        lines.append(f"\nBOIDS_SIMULATION_SCORE: {total}/100\n")
        lines.append("Recommendations:")
        if self.scores["flocking"] < self.weights["flocking"]:
            lines.append("- Improve flocking cohesion algorithm.")
        if self.scores["spatialHashEfficiency"] < self.weights["spatialHashEfficiency"]:
            lines.append("- Optimize spatial hash grid cell size and update frequency.")
        if self.scores["obstacleAvoidance"] < self.weights["obstacleAvoidance"]:
            lines.append("- Enhance obstacle avoidance steering precision.")
        if self.scores["predatorPreyInteractions"] < self.weights["predatorPreyInteractions"]:
            lines.append("- Refine predator hunting and prey evasion logic.")
        if self.scores["performanceOptimization"] < self.weights["performanceOptimization"]:
            lines.append("- Apply further algorithm and data structure optimizations.")
        return "\n".join(lines)

# Main Simulation Class
class BoidsSimulation:
    """Main simulation class managing agents, updates, and rendering."""
    def __init__(self, configPath: Optional[str] = None, autoTest: bool = False):
        pygame.init()
        self.config = ConfigManager(configPath)
        self.width = self.config.get("windowWidth", 1200)
        self.height = self.config.get("windowHeight", 800)
        self.screen = pygame.display.set_mode((self.width, self.height))
        pygame.display.set_caption("Boids++ Simulation")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont("Consolas", 18)
        self.gridCellSize = self.config.get("gridCellSize", 60)
        self.grid = SpatialHashGrid(self.width, self.height, self.gridCellSize)
        self.speedMultiplier = self.config.get("speedMultiplier", 1.0)
        self.visualizationModes = self.config.get("visualizationModes", ["agents", "grid", "stats"])
        self.visualizationMode = self.config.get("initialVisualizationMode", "agents")
        self.autoTest = autoTest
        self.autoTestStart = None
        self.autoTestDuration = self.config.get("autoTestDuration", 30)
        self.autoTestSwitchInterval = self.config.get("autoTestSwitchInterval", 10)
        self.autoTestSpeedMultiplier = self.config.get("autoTestSpeedMultiplier", 5.0)
        self.agentLock = threading.Lock()

        self.agents: List[Agent] = []
        self.boids: List[Boid] = []
        self.predators: List[Predator] = []
        self.obstacles: List[Obstacle] = []
        self.leaders: List[Leader] = []

        self.scoreManager = ScoreManager()

        self.initAgents()
        self.fpsHistory = deque(maxlen=120)  # Last 2 seconds fps sampling
        self.frameCount = 0
        self.lastPerfCheck = time.time()

        # Performance and optimization flags
        self.optimizationRequired = False

    def initAgents(self):
        """Initialize agents according to config."""
        boidCount = self.config.get("boidCount", 180)
        predatorCount = self.config.get("predatorCount", 10)
        obstacleCount = self.config.get("obstacleCount", 15)
        leaderCount = self.config.get("leaderCount", 5)

        # Initialize Boids
        for _ in range(boidCount):
            pos = np.array([random.uniform(0, self.width), random.uniform(0, self.height)], dtype=np.float32)
            angle = random.uniform(0, 2 * math.pi)
            vel = np.array([math.cos(angle), math.sin(angle)], dtype=np.float32) * random.uniform(1, 3)
            boid = Boid(pos, vel, self.config)
            self.boids.append(boid)
            self.agents.append(boid)

        # Initialize Predators
        for _ in range(predatorCount):
            pos = np.array([random.uniform(0, self.width), random.uniform(0, self.height)], dtype=np.float32)
            angle = random.uniform(0, 2 * math.pi)
            vel = np.array([math.cos(angle), math.sin(angle)], dtype=np.float32) * random.uniform(1, 2)
            predator = Predator(pos, vel, self.config)
            self.predators.append(predator)
            self.agents.append(predator)

        # Initialize Obstacles
        for _ in range(obstacleCount):
            pos = np.array([random.uniform(50, self.width - 50), random.uniform(50, self.height - 50)], dtype=np.float32)
            radius = random.randint(15, 30)
            obstacle = Obstacle(pos, radius, self.config)
            self.obstacles.append(obstacle)
            self.agents.append(obstacle)

        # Initialize Leaders
        for _ in range(leaderCount):
            pos = np.array([random.uniform(0, self.width), random.uniform(0, self.height)], dtype=np.float32)
            angle = random.uniform(0, 2 * math.pi)
            vel = np.array([math.cos(angle), math.sin(angle)], dtype=np.float32) * random.uniform(1, 3)
            leader = Leader(pos, vel, self.config)
            self.leaders.append(leader)
            self.agents.append(leader)

    def handleEvents(self):
        """Handle user input events."""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                elif event.key == pygame.K_g:
                    # Toggle grid visualization
                    if "grid" in self.visualizationModes:
                        if self.visualizationMode == "grid":
                            self.visualizationMode = "agents"
                        else:
                            self.visualizationMode = "grid"
                elif event.key == pygame.K_s:
                    # Toggle stats visualization
                    if "stats" in self.visualizationModes:
                        if self.visualizationMode == "stats":
                            self.visualizationMode = "agents"
                        else:
                            self.visualizationMode = "stats"
                elif event.key == pygame.K_PLUS or event.key == pygame.K_EQUALS:
                    # Increase speed multiplier
                    self.speedMultiplier = min(10.0, self.speedMultiplier + 0.1)
                elif event.key == pygame.K_MINUS or event.key == pygame.K_UNDERSCORE:
                    # Decrease speed multiplier
                    self.speedMultiplier = max(0.1, self.speedMultiplier - 0.1)
                elif event.key == pygame.K_r:
                    # Reset simulation
                    self.resetSimulation()

    def resetSimulation(self):
        self.agents.clear()
        self.boids.clear()
        self.predators.clear()
        self.obstacles.clear()
        self.leaders.clear()
        self.initAgents()

    def update(self, deltaTime: float):
        """Update all agents."""
        # Update spatial grid for neighbor queries
        with self.agentLock:
            self.grid.update([agent for agent in self.agents if agent.active])

        # Update Boids flocking
        for boid in self.boids:
            if not boid.active:
                continue
            neighbors = self.grid.neighbors(boid, self.config.get("neighborRadius", 60))
            boid.flock(neighbors, self.obstacles, self.predators, self.leaders, self.width, self.height)
            boid.update(deltaTime * self.speedMultiplier)
            boid.edges(self.width, self.height)

        # Update Predators hunting
        for predator in self.predators:
            if not predator.active:
                continue
            predator.hunt(self.boids, self.grid, self.width, self.height)
            predator.update(deltaTime * self.speedMultiplier)
            predator.edges(self.width, self.height)

        # Leaders update
        for leader in self.leaders:
            leader.update(deltaTime * self.speedMultiplier)
            leader.edges(self.width, self.height)

        # Obstacles do not update

        # Remove inactive boids (preyed upon)
        removed = 0
        with self.agentLock:
            for boid in self.boids:
                if not boid.active:
                    try:
                        self.agents.remove(boid)
                        removed += 1
                    except ValueError:
                        pass
            self.boids = [b for b in self.boids if b.active]

        if removed > 0:
            print(f"[Simulation] Removed {removed} boids due to predator capture.")

    def draw(self):
        self.screen.fill(self.config.get("backgroundColor", (25, 25, 25)))
        if self.visualizationMode == "grid":
            self.grid.drawGrid(self.screen, self.config.get("gridColor", (50, 50, 50)))

        for agent in self.agents:
            if agent.active:
                agent.draw(self.screen)

        if self.visualizationMode == "stats":
            self.drawStats()

        # Draw FPS and info
        fps = self.clock.get_fps()
        fpsText = self.font.render(f"FPS: {fps:.1f} | Agents: {len(self.agents)} | Speed x{self.speedMultiplier:.1f} | Mode: {self.visualizationMode}", True, (200, 200, 200))
        self.screen.blit(fpsText, (10, 10))

        pygame.display.flip()

    def drawStats(self):
        y = 40
        spacing = 20
        stats = [
            f"Boids: {len(self.boids)}",
            f"Predators: {len(self.predators)}",
            f"Obstacles: {len(self.obstacles)}",
            f"Leaders: {len(self.leaders)}",
            f"Grid Cells: {len(self.grid.cells)}",
            f"Avg FPS: {np.mean(self.fpsHistory) if self.fpsHistory else 0:.1f}",
        ]
        for stat in stats:
            text = self.font.render(stat, True, (180, 180, 180))
            self.screen.blit(text, (10, y))
            y += spacing

    def monitorPerformance(self):
        fps = self.clock.get_fps()
        self.fpsHistory.append(fps)
        self.frameCount += 1
        now = time.time()
        if now - self.lastPerfCheck > 5.0:
            avgFps = np.mean(self.fpsHistory) if self.fpsHistory else 0.0
            agentCount = len(self.agents)
            self.scoreManager.calculatePerformanceScore(avgFps, agentCount)
            if avgFps < 30 and not self.optimizationRequired:
                print("[Performance] FPS dropped below 30, optimization required.")
                self.optimizationRequired = True
            self.lastPerfCheck = now

    def runAutoTest(self):
        """Run accelerated 30-second auto test with scenario switching."""
        self.autoTestStart = time.time()
        switchTimes = [0, 10, 20, 30]  # seconds
        currentScenario = 0
        print("[AutoTest] Starting 30-second accelerated testing mode.")
        self.speedMultiplier = self.autoTestSpeedMultiplier
        running = True
        while running:
            now = time.time()
            elapsed = now - self.autoTestStart
            if elapsed >= self.autoTestDuration:
                running = False
                break

            if elapsed >= switchTimes[currentScenario + 1]:
                currentScenario += 1
                print(f"[AutoTest] Switching scenario to {currentScenario} at {elapsed:.1f}s")
                # Switch scenarios accordingly
                if currentScenario == 1:
                    # Predator-prey scenario: Ensure predators and boids active
                    self.resetSimulation()
                elif currentScenario == 2:
                    # Obstacles scenario: Add more obstacles, fewer predators
                    self.resetSimulation()
                    # Remove predators for obstacle test
                    for p in self.predators:
                        try:
                            self.agents.remove(p)
                        except ValueError:
                            pass
                    self.predators.clear()
                elif currentScenario == 3:
                    # End of test
                    running = False
                    break

            self.handleEvents()
            deltaTime = self.clock.tick(self.config.get("fpsTarget", 60)) / 1000.0
            self.update(deltaTime)
            self.draw()
            self.monitorPerformance()

            # Print progress every 5 seconds
            if int(elapsed) % 5 == 0:
                print(f"[AutoTest] Progress: {elapsed:.1f}/{self.autoTestDuration} seconds")

        print("BOIDS_SIMULATION_COMPLETE_SUCCESS")
        print(self.scoreManager.report())
        pygame.quit()
        sys.exit()

    def run(self):
        if self.autoTest:
            self.runAutoTest()

        while True:
            self.handleEvents()
            deltaTime = self.clock.tick(self.config.get("fpsTarget", 60)) / 1000.0
            self.update(deltaTime)
            self.draw()
            self.monitorPerformance()

# Entry point
def main():
    autoTest = False
    configPath = None
    for arg in sys.argv[1:]:
        if arg.startswith("--config="):
            configPath = arg.split("=", 1)[1]
        if arg == "--auto-test":
            autoTest = True
    sim = BoidsSimulation(configPath=configPath, autoTest=autoTest)
    sim.run()

if __name__ == "__main__":
    main()

