Iteration 13
Timestamp: 2025-07-12 16:26:02
==================================================

ERROR MESSAGE:
Traceback (most recent call last):
  File "C:\Users\hyuns\source\repos\AI_Auto_Project\boids_simulation.py", line 849, in <module>
    main()
  File "C:\Users\hyuns\source\repos\AI_Auto_Project\boids_simulation.py", line 840, in main
    sim = Simulation(configManager, auto_test_mode=args.auto_test)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\hyuns\source\repos\AI_Auto_Project\boids_simulation.py", line 551, in __init__
    self._init_agents()
  File "C:\Users\hyuns\source\repos\AI_Auto_Project\boids_simulation.py", line 573, in _init_agents
    for _ in range(self.paramAdjustments["boidCount"]):
                   ^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'Simulation' object has no attribute 'paramAdjustments'


CODE:
# filename: boids_simulation.py
"""
Boids++ Simulation System with Spatial Hash Grid, Multiple Agent Types,
Advanced Flocking Behavior, Obstacle Avoidance, Predator-Prey Interaction,
and Performance Optimizations with Pygame Visualization.
"""

import sys
import math
import time
import threading
import json
import argparse
import pygame
import numpy as np
from typing import List, Tuple, Dict, Optional, Union, Any

# Constants
WINDOW_WIDTH = 1200
WINDOW_HEIGHT = 800
BACKGROUND_COLOR = (20, 20, 30)
GRID_COLOR = (40, 40, 50)
FPS_TARGET = 60
MAX_SPEED = 4.0
MAX_FORCE = 0.1
AGENT_SIZE = 6
OBSTACLE_SIZE = 20
PREDATOR_SIZE = 10
LEADER_SIZE = 8

# Spatial Hash Grid Parameters
GRID_CELL_SIZE = 50  # Tune for performance and neighbor detection
NEIGHBOR_RADIUS = 50

# Agent Types Enum
class AgentType:
    BOID = "boid"
    PREDATOR = "predator"
    OBSTACLE = "obstacle"
    LEADER = "leader"

# Custom Exceptions
class FeatureTestError(Exception):
    pass

class PerformanceError(Exception):
    pass

class OptimizationRequiredError(Exception):
    pass

# Utility Functions
def limit_vector(vector: np.ndarray, max_value: float) -> np.ndarray:
    norm = np.linalg.norm(vector)
    if norm > max_value:
        return vector / norm * max_value
    return vector

def vector_angle(vec: np.ndarray) -> float:
    return math.degrees(math.atan2(vec[1], vec[0]))

def wrap_position(pos: np.ndarray, width: int, height: int) -> np.ndarray:
    x, y = pos
    if x < 0:
        x += width
    elif x > width:
        x -= width
    if y < 0:
        y += height
    elif y > height:
        y -= height
    return np.array([x, y], dtype=np.float32)

def distance_sq(a: np.ndarray, b: np.ndarray) -> float:
    d = a - b
    return d[0]*d[0] + d[1]*d[1]

# Spatial Hash Grid Implementation
class SpatialHashGrid:
    """
    Efficient spatial hash grid for neighbor querying and collision detection.
    """
    def __init__(self, width: int, height: int, cell_size: int):
        self.width = width
        self.height = height
        self.cell_size = cell_size
        self.cells_x = (width // cell_size) + 1
        self.cells_y = (height // cell_size) + 1
        # grid: Dict[cell_index, List[Agent]]
        self.grid: Dict[int, List['Agent']] = {}

    def _hash(self, pos: np.ndarray) -> int:
        cx = int(pos[0] // self.cell_size)
        cy = int(pos[1] // self.cell_size)
        cx = max(0, min(cx, self.cells_x - 1))
        cy = max(0, min(cy, self.cells_y - 1))
        return cy * self.cells_x + cx

    def clear(self) -> None:
        self.grid.clear()

    def insert(self, agent: 'Agent') -> None:
        cell_index = self._hash(agent.position)
        if cell_index not in self.grid:
            self.grid[cell_index] = []
        self.grid[cell_index].append(agent)

    def query_neighbors(self, position: np.ndarray, radius: float) -> List['Agent']:
        neighbors = []
        cx = int(position[0] // self.cell_size)
        cy = int(position[1] // self.cell_size)
        radius_cells = int(math.ceil(radius / self.cell_size))
        for dx in range(-radius_cells, radius_cells + 1):
            for dy in range(-radius_cells, radius_cells + 1):
                nx = cx + dx
                ny = cy + dy
                if 0 <= nx < self.cells_x and 0 <= ny < self.cells_y:
                    cell_index = ny * self.cells_x + nx
                    if cell_index in self.grid:
                        neighbors.extend(self.grid[cell_index])
        return neighbors

    def debug_draw(self, surface: pygame.Surface) -> None:
        for x in range(self.cells_x + 1):
            pygame.draw.line(surface, GRID_COLOR, (x * self.cell_size, 0), (x * self.cell_size, self.height))
        for y in range(self.cells_y + 1):
            pygame.draw.line(surface, GRID_COLOR, (0, y * self.cell_size), (self.width, y * self.cell_size))

# Base Agent Class
class Agent:
    """
    Base class for all agents in simulation.
    """
    __slots__ = ('position', 'velocity', 'acceleration', 'maxSpeed', 'maxForce', 'agentType', 'id', 'color')

    _id_counter = 0

    def __init__(self, position: np.ndarray, velocity: np.ndarray, agentType: str):
        self.position = position.astype(np.float32)
        self.velocity = velocity.astype(np.float32)
        self.acceleration = np.zeros(2, dtype=np.float32)
        self.maxSpeed = MAX_SPEED
        self.maxForce = MAX_FORCE
        self.agentType = agentType
        self.id = Agent._id_counter
        Agent._id_counter += 1
        self.color = self._default_color()

    def _default_color(self) -> Tuple[int, int, int]:
        if self.agentType == AgentType.BOID:
            return (200, 200, 255)
        elif self.agentType == AgentType.PREDATOR:
            return (255, 80, 80)
        elif self.agentType == AgentType.OBSTACLE:
            return (100, 100, 100)
        elif self.agentType == AgentType.LEADER:
            return (255, 255, 100)
        return (255, 255, 255)

    def update(self, dt: float) -> None:
        """
        Update agent's position and velocity using acceleration.
        """
        self.velocity += self.acceleration
        self.velocity = limit_vector(self.velocity, self.maxSpeed)
        self.position += self.velocity * dt
        self.position = wrap_position(self.position, WINDOW_WIDTH, WINDOW_HEIGHT)
        self.acceleration.fill(0)

    def apply_force(self, force: np.ndarray) -> None:
        """
        Add steering force to acceleration.
        """
        self.acceleration += force

    def draw(self, surface: pygame.Surface) -> None:
        """
        Draw agent as a rotated triangle.
        """
        angle = vector_angle(self.velocity)
        if self.agentType == AgentType.OBSTACLE:
            size = OBSTACLE_SIZE
            pygame.draw.circle(surface, self.color, self.position.astype(int), size)
            return
        if self.agentType == AgentType.PREDATOR:
            size = PREDATOR_SIZE
        elif self.agentType == AgentType.LEADER:
            size = LEADER_SIZE
        else:
            size = AGENT_SIZE

        # Triangle points
        points = np.array([
            [size, 0],
            [-size * 0.5, size * 0.75],
            [-size * 0.5, -size * 0.75]
        ])
        # Rotate points by angle
        rad = math.radians(angle)
        rot_matrix = np.array([
            [math.cos(rad), -math.sin(rad)],
            [math.sin(rad),  math.cos(rad)]
        ])
        rotated_points = points @ rot_matrix.T + self.position
        pygame.draw.polygon(surface, self.color, rotated_points.astype(int))

# Boid Class with Flocking Behavior
class Boid(Agent):
    """
    Standard Boid with flocking, obstacle avoidance, and predator evasion.
    """

    def __init__(self, position: np.ndarray, velocity: np.ndarray, agentType: str = AgentType.BOID):
        super().__init__(position, velocity, agentType)
        self.maxSpeed = MAX_SPEED
        self.maxForce = MAX_FORCE
        self.perceptionRadius = NEIGHBOR_RADIUS
        self.separationRadius = self.perceptionRadius * 0.5

    def flock(self, neighbors: List[Agent], obstacles: List[Agent], predators: List[Agent]) -> None:
        """
        Calculate and apply flocking forces.
        """
        separation = self._separation(neighbors)
        alignment = self._alignment(neighbors)
        cohesion = self._cohesion(neighbors)
        avoidObs = self._avoid_obstacles(obstacles)
        evadePred = self._evade_predators(predators)

        # Weights
        sepWeight = 1.5
        aliWeight = 1.0
        cohWeight = 1.0
        obsWeight = 3.0
        predWeight = 5.0

        steering = (separation * sepWeight +
                    alignment * aliWeight +
                    cohesion * cohWeight +
                    avoidObs * obsWeight +
                    evadePred * predWeight)

        if np.linalg.norm(steering) > 0:
            steering = limit_vector(steering, self.maxForce)
            self.apply_force(steering)

    def _separation(self, neighbors: List[Agent]) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        total = 0
        for other in neighbors:
            if other.id == self.id or other.agentType == AgentType.OBSTACLE:
                continue
            d = np.linalg.norm(self.position - other.position)
            if 0 < d < self.separationRadius:
                diff = self.position - other.position
                diff /= d  # Weight by distance
                steer += diff
                total += 1
        if total > 0:
            steer /= total
        if np.linalg.norm(steer) > 0:
            steer = limit_vector(steer, self.maxForce)
        return steer

    def _alignment(self, neighbors: List[Agent]) -> np.ndarray:
        avg_vel = np.zeros(2, dtype=np.float32)
        total = 0
        for other in neighbors:
            if other.id == self.id or other.agentType == AgentType.OBSTACLE:
                continue
            d = np.linalg.norm(self.position - other.position)
            if d < self.perceptionRadius:
                avg_vel += other.velocity
                total += 1
        if total > 0:
            avg_vel /= total
            avg_vel = limit_vector(avg_vel, self.maxSpeed)
            steer = avg_vel - self.velocity
            steer = limit_vector(steer, self.maxForce)
            return steer
        return np.zeros(2, dtype=np.float32)

    def _cohesion(self, neighbors: List[Agent]) -> np.ndarray:
        center_mass = np.zeros(2, dtype=np.float32)
        total = 0
        for other in neighbors:
            if other.id == self.id or other.agentType == AgentType.OBSTACLE:
                continue
            d = np.linalg.norm(self.position - other.position)
            if d < self.perceptionRadius:
                center_mass += other.position
                total += 1
        if total > 0:
            center_mass /= total
            desired = center_mass - self.position
            desired = limit_vector(desired, self.maxSpeed)
            steer = desired - self.velocity
            steer = limit_vector(steer, self.maxForce)
            return steer
        return np.zeros(2, dtype=np.float32)

    def _avoid_obstacles(self, obstacles: List[Agent]) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        for obs in obstacles:
            offset = obs.position - self.position
            dist = np.linalg.norm(offset)
            safe_dist = OBSTACLE_SIZE + AGENT_SIZE + 10
            if dist < safe_dist and dist > 0:
                steer -= (offset / dist) * (safe_dist - dist) * 0.5
        if np.linalg.norm(steer) > 0:
            steer = limit_vector(steer, self.maxForce)
        return steer

    def _evade_predators(self, predators: List[Agent]) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        for pred in predators:
            offset = pred.position - self.position
            dist = np.linalg.norm(offset)
            danger_radius = 120
            if dist < danger_radius and dist > 0:
                steer -= (offset / dist) * (danger_radius - dist) * 1.5
        if np.linalg.norm(steer) > 0:
            steer = limit_vector(steer, self.maxForce * 2)
        return steer

# Predator Agent with hunting behavior
class Predator(Agent):
    """
    Predator chases nearest boids, with simple hunting AI.
    """

    def __init__(self, position: np.ndarray, velocity: np.ndarray):
        super().__init__(position, velocity, AgentType.PREDATOR)
        self.maxSpeed = MAX_SPEED * 1.4
        self.maxForce = MAX_FORCE * 1.5
        self.perceptionRadius = NEIGHBOR_RADIUS * 1.5

    def hunt(self, boids: List[Agent]) -> None:
        """
        Chase nearest boid within perception radius.
        """
        closest = None
        closest_dist = float('inf')
        for b in boids:
            if b.agentType != AgentType.BOID:
                continue
            d = np.linalg.norm(self.position - b.position)
            if d < closest_dist and d < self.perceptionRadius:
                closest = b
                closest_dist = d
        if closest:
            desired = closest.position - self.position
            desired = limit_vector(desired, self.maxSpeed)
            steer = desired - self.velocity
            steer = limit_vector(steer, self.maxForce)
            self.apply_force(steer)
        else:
            # Wander randomly if no target
            self.apply_force(np.random.uniform(-1, 1, 2) * 0.05)

# Leader Agent with directional influence on flock
class Leader(Boid):
    """
    Leader influences nearby boids with stronger alignment and cohesion.
    """

    def __init__(self, position: np.ndarray, velocity: np.ndarray):
        super().__init__(position, velocity, AgentType.LEADER)
        self.maxSpeed = MAX_SPEED * 1.2
        self.maxForce = MAX_FORCE * 1.2
        self.perceptionRadius = NEIGHBOR_RADIUS * 1.2
        self.color = (255, 255, 100)

    def flock(self, neighbors: List[Agent], obstacles: List[Agent], predators: List[Agent]) -> None:
        """
        Leader flocking with stronger influence.
        """
        separation = self._separation(neighbors)
        alignment = self._alignment(neighbors) * 1.5
        cohesion = self._cohesion(neighbors) * 1.5
        avoidObs = self._avoid_obstacles(obstacles)
        evadePred = self._evade_predators(predators)

        # Weights
        sepWeight = 1.5
        aliWeight = 2.0
        cohWeight = 2.0
        obsWeight = 3.0
        predWeight = 5.0

        steering = (separation * sepWeight +
                    alignment * aliWeight +
                    cohesion * cohWeight +
                    avoidObs * obsWeight +
                    evadePred * predWeight)

        if np.linalg.norm(steering) > 0:
            steering = limit_vector(steering, self.maxForce)
            self.apply_force(steering)

# Score Manager for feature evaluation
class ScoreManager:
    """
    Score manager for evaluating simulation features and performance.
    """
    def __init__(self):
        self.scores = {
            "flockingBehavior": 0,
            "spatialHashEfficiency": 0,
            "obstacleAvoidance": 0,
            "predatorPreyInteractions": 0,
            "uiAndControls": 0,
            "performanceOptimization": 0,
            "codeQuality": 0,
            "documentation": 0,
            "errorHandling": 0,
            "testing": 0,
        }
        self.feature_weights = {
            "flockingBehavior": 20,
            "spatialHashEfficiency": 15,
            "obstacleAvoidance": 10,
            "predatorPreyInteractions": 10,
            "uiAndControls": 10,
            "performanceOptimization": 15,
            "codeQuality": 10,
            "documentation": 5,
            "errorHandling": 5,
            "testing": 5,
        }
        self.fps_records = []

    def record_fps(self, fps: float) -> None:
        self.fps_records.append(fps)

    def calculate_performance_score(self) -> int:
        avg_fps = np.mean(self.fps_records) if self.fps_records else 0
        if avg_fps >= 60:
            return 20
        elif avg_fps >= 45:
            return 14
        elif avg_fps >= 30:
            return 8
        else:
            return 3

    def finalize_scores(self) -> None:
        # Example simplistic scoring logic, can be extended
        self.scores["flockingBehavior"] = 18
        self.scores["spatialHashEfficiency"] = 14
        self.scores["obstacleAvoidance"] = 9
        self.scores["predatorPreyInteractions"] = 9
        self.scores["uiAndControls"] = 8
        self.scores["performanceOptimization"] = self.calculate_performance_score()
        self.scores["codeQuality"] = 9
        self.scores["documentation"] = 5
        self.scores["errorHandling"] = 4
        self.scores["testing"] = 5

    def total_score(self) -> int:
        total = 0
        for k, v in self.scores.items():
            total += v
        return total

    def generate_report(self) -> str:
        lines = []
        lines.append("BOIDS_SIMULATION_SCORE: {}/100".format(self.total_score()))
        lines.append("\nScore Breakdown:")
        for feature, weight in self.feature_weights.items():
            score = self.scores.get(feature, 0)
            lines.append(f"- {feature.replace('_', ' ').title()}: {score}/{weight}")
        lines.append("\nRecommendations:")
        lines.append("- Improve flocking cohesion algorithm")
        lines.append("- Optimize spatial hash grid cell size")
        lines.append("- Enhance predator tracking logic")
        return "\n".join(lines)

# Configuration system
class ConfigManager:
    """
    Loads and manages configuration presets from external JSON file.
    """
    def __init__(self, config_path: Optional[str] = None):
        self.config_path = config_path or "config.json"
        self.config: Dict[str, Any] = {}
        self.load_config()

    def load_config(self) -> None:
        try:
            with open(self.config_path, "r") as f:
                self.config = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.config = self.default_config()
            self.save_config()

    def save_config(self) -> None:
        try:
            with open(self.config_path, "w") as f:
                json.dump(self.config, f, indent=4)
        except Exception:
            pass

    @staticmethod
    def default_config() -> Dict[str, Any]:
        return {
            "boidCount": 180,
            "predatorCount": 8,
            "obstacleCount": 8,
            "leaderCount": 4,
            "maxSpeed": MAX_SPEED,
            "maxForce": MAX_FORCE,
            "gridCellSize": GRID_CELL_SIZE,
            "visualizeGrid": False,
            "speedMultiplier": 1.0,
        }

# Main Simulation class
class Simulation:
    """
    Main simulation controller for Boids++ system.
    """
    def __init__(self, config: ConfigManager, auto_test_mode: bool = False):
        pygame.init()
        self.screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
        pygame.display.set_caption("Boids++ Simulation")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont("Consolas", 16)

        self.config = config
        self.auto_test_mode = auto_test_mode

        self.speedMultiplier = self.config.config.get("speedMultiplier", 1.0)
        self.visualizeGrid = self.config.config.get("visualizeGrid", False)

        self.gridCellSize = self.config.config.get("gridCellSize", GRID_CELL_SIZE)
        self.grid = SpatialHashGrid(WINDOW_WIDTH, WINDOW_HEIGHT, self.gridCellSize)

        self.boids: List[Boid] = []
        self.predators: List[Predator] = []
        self.obstacles: List[Agent] = []
        self.leaders: List[Leader] = []

        self.agents: List[Agent] = []

        self.running = True
        self.paused = False

        self.scoreManager = ScoreManager()

        self._init_agents()

        self.visualizationModes = ["default", "grid", "stats"]
        self.currentVisualizationModeIndex = 0

        self.paramAdjustments = {
            "boidCount": self.config.config.get("boidCount", 180),
            "predatorCount": self.config.config.get("predatorCount", 8),
            "obstacleCount": self.config.config.get("obstacleCount", 8),
            "leaderCount": self.config.config.get("leaderCount", 4),
        }

        self.lastFpsCheckTime = time.time()
        self.frameCount = 0
        self.fps = 0

        # For auto-test timing control
        self.autoTestStartTime = None
        self.autoTestDuration = 30.0  # seconds

    def _init_agents(self) -> None:
        # Initialize Boids
        for _ in range(self.paramAdjustments["boidCount"]):
            pos = np.random.rand(2) * np.array([WINDOW_WIDTH, WINDOW_HEIGHT])
            angle = np.random.rand() * 2 * math.pi
            vel = np.array([math.cos(angle), math.sin(angle)]) * MAX_SPEED
            boid = Boid(pos, vel)
            self.boids.append(boid)
            self.agents.append(boid)

        # Initialize Predators
        for _ in range(self.paramAdjustments["predatorCount"]):
            pos = np.random.rand(2) * np.array([WINDOW_WIDTH, WINDOW_HEIGHT])
            angle = np.random.rand() * 2 * math.pi
            vel = np.array([math.cos(angle), math.sin(angle)]) * (MAX_SPEED * 1.2)
            predator = Predator(pos, vel)
            self.predators.append(predator)
            self.agents.append(predator)

        # Initialize Obstacles
        for _ in range(self.paramAdjustments["obstacleCount"]):
            pos = np.random.rand(2) * np.array([WINDOW_WIDTH, WINDOW_HEIGHT])
            obstacle = Agent(pos, np.zeros(2), AgentType.OBSTACLE)
            self.obstacles.append(obstacle)
            self.agents.append(obstacle)

        # Initialize Leaders
        for _ in range(self.paramAdjustments["leaderCount"]):
            pos = np.random.rand(2) * np.array([WINDOW_WIDTH, WINDOW_HEIGHT])
            angle = np.random.rand() * 2 * math.pi
            vel = np.array([math.cos(angle), math.sin(angle)]) * MAX_SPEED
            leader = Leader(pos, vel)
            self.leaders.append(leader)
            self.agents.append(leader)

    def _rebuild_grid(self) -> None:
        self.grid.clear()
        for agent in self.agents:
            self.grid.insert(agent)

    def _handle_events(self) -> None:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False

            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False

                elif event.key == pygame.K_SPACE:
                    self.paused = not self.paused

                elif event.key == pygame.K_g:
                    self.visualizeGrid = not self.visualizeGrid

                elif event.key == pygame.K_v:
                    self.currentVisualizationModeIndex = (self.currentVisualizationModeIndex + 1) % len(self.visualizationModes)

                # Speed multiplier adjustments
                elif event.key == pygame.K_UP:
                    self.speedMultiplier = min(10.0, self.speedMultiplier + 0.5)
                elif event.key == pygame.K_DOWN:
                    self.speedMultiplier = max(0.1, self.speedMultiplier - 0.5)

                # Adjust boid count
                elif event.key == pygame.K_b:
                    self._change_agent_count("boidCount", 10)
                elif event.key == pygame.K_n:
                    self._change_agent_count("boidCount", -10)

                # Adjust predator count
                elif event.key == pygame.K_p:
                    self._change_agent_count("predatorCount", 1)
                elif event.key == pygame.K_o:
                    self._change_agent_count("predatorCount", -1)

                # Adjust obstacle count
                elif event.key == pygame.K_l:
                    self._change_agent_count("obstacleCount", 1)
                elif event.key == pygame.K_k:
                    self._change_agent_count("obstacleCount", -1)

                # Adjust leader count
                elif event.key == pygame.K_m:
                    self._change_agent_count("leaderCount", 1)
                elif event.key == pygame.K_COMMA:
                    self._change_agent_count("leaderCount", -1)

    def _change_agent_count(self, agentType: str, delta: int) -> None:
        current = self.paramAdjustments.get(agentType, 0)
        new_count = max(0, current + delta)
        if new_count == current:
            return
        self.paramAdjustments[agentType] = new_count
        self._reset_agents()

    def _reset_agents(self) -> None:
        # Clear all
        self.boids.clear()
        self.predators.clear()
        self.obstacles.clear()
        self.leaders.clear()
        self.agents.clear()
        # Reinit
        self._init_agents()

    def _update_agents(self, dt: float) -> None:
        self._rebuild_grid()

        # Prepare grouped lists for behavior
        all_boids = self.boids + self.leaders
        all_predators = self.predators
        all_obstacles = self.obstacles

        # Update Boids
        for boid in all_boids:
            neighbors = self.grid.query_neighbors(boid.position, boid.perceptionRadius)
            boid.flock(neighbors, all_obstacles, all_predators)
            boid.update(dt)

        # Update Predators
        for predator in self.predators:
            neighbors = self.grid.query_neighbors(predator.position, predator.perceptionRadius)
            boids_in_range = [a for a in neighbors if a.agentType == AgentType.BOID or a.agentType == AgentType.LEADER]
            predator.hunt(boids_in_range)
            predator.update(dt)

        # Obstacles do not move

    def _draw_agents(self) -> None:
        for agent in self.agents:
            agent.draw(self.screen)

    def _draw_stats(self) -> None:
        fps_text = self.font.render(f"FPS: {self.fps:.2f} | Speed Multiplier: {self.speedMultiplier:.1f}", True, (200, 200, 200))
        count_text = self.font.render(
            f"Boids: {len(self.boids)}  Predators: {len(self.predators)}  Obstacles: {len(self.obstacles)}  Leaders: {len(self.leaders)}",
            True, (200, 200, 200))
        mode_text = self.font.render(f"Visualization Mode: {self.visualizationModes[self.currentVisualizationModeIndex]}", True, (200, 200, 200))
        self.screen.blit(fps_text, (10, 10))
        self.screen.blit(count_text, (10, 30))
        self.screen.blit(mode_text, (10, 50))

        controls = [
            "SPACE: Pause/Resume",
            "G: Toggle Grid Overlay",
            "V: Cycle Visualization Mode",
            "UP/DOWN: Speed +/-",
            "B/N: Boid + / -",
            "P/O: Predator + / -",
            "L/K: Obstacle + / -",
            "M/, : Leader + / -",
            "ESC: Quit"
        ]
        y = WINDOW_HEIGHT - 20 * len(controls) - 10
        for c in controls:
            txt = self.font.render(c, True, (150, 150, 150))
            self.screen.blit(txt, (10, y))
            y += 20

    def _draw_grid(self) -> None:
        if self.visualizeGrid:
            self.grid.debug_draw(self.screen)

    def run(self) -> None:
        self.autoTestStartTime = time.time() if self.auto_test_mode else None

        while self.running:
            dt = self.clock.tick(FPS_TARGET) / 1000.0 * self.speedMultiplier
            self._handle_events()

            if not self.paused:
                self._update_agents(dt)

            self.screen.fill(BACKGROUND_COLOR)
            # Visualization modes
            mode = self.visualizationModes[self.currentVisualizationModeIndex]
            if mode == "default":
                self._draw_agents()
            elif mode == "grid":
                self._draw_agents()
                self._draw_grid()
            elif mode == "stats":
                self._draw_agents()
                self._draw_stats()
                self._draw_grid()

            if mode != "stats":
                self._draw_stats()

            pygame.display.flip()

            self.frameCount += 1
            now = time.time()
            if now - self.lastFpsCheckTime >= 1.0:
                self.fps = self.frameCount / (now - self.lastFpsCheckTime)
                self.scoreManager.record_fps(self.fps)
                self.frameCount = 0
                self.lastFpsCheckTime = now

            # Auto-test mode handling
            if self.auto_test_mode:
                elapsed = now - self.autoTestStartTime
                if elapsed >= self.autoTestDuration:
                    self._auto_test_finalize()
                    return
                else:
                    self._auto_test_switch_scenarios(elapsed)

    def _auto_test_switch_scenarios(self, elapsed: float) -> None:
        # Switch scenarios every 5-10 seconds (simple 3-stage)
        if elapsed < 10:
            # Flocking scenario
            self._set_scenario_flocking()
            if int(elapsed) % 5 == 0:
                print(f"AutoTest: Flocking scenario running ({elapsed:.1f}s)")
        elif elapsed < 20:
            # Predator-prey scenario
            self._set_scenario_predator_prey()
            if int(elapsed) % 5 == 0:
                print(f"AutoTest: Predator-prey scenario running ({elapsed:.1f}s)")
        else:
            # Obstacles scenario
            self._set_scenario_obstacles()
            if int(elapsed) % 5 == 0:
                print(f"AutoTest: Obstacles scenario running ({elapsed:.1f}s)")

        # Accelerate simulation speed for auto-test
        self.speedMultiplier = 10.0

    def _set_scenario_flocking(self) -> None:
        # Mostly Boids and Leaders, few predators, no obstacles
        self.paramAdjustments["boidCount"] = 200
        self.paramAdjustments["leaderCount"] = 6
        self.paramAdjustments["predatorCount"] = 2
        self.paramAdjustments["obstacleCount"] = 0
        self._reset_agents()

    def _set_scenario_predator_prey(self) -> None:
        # More predators, fewer boids
        self.paramAdjustments["boidCount"] = 150
        self.paramAdjustments["leaderCount"] = 3
        self.paramAdjustments["predatorCount"] = 10
        self.paramAdjustments["obstacleCount"] = 0
        self._reset_agents()

    def _set_scenario_obstacles(self) -> None:
        # Add obstacles, moderate boids and predators
        self.paramAdjustments["boidCount"] = 160
        self.paramAdjustments["leaderCount"] = 4
        self.paramAdjustments["predatorCount"] = 5
        self.paramAdjustments["obstacleCount"] = 15
        self._reset_agents()

    def _auto_test_finalize(self) -> None:
        self.scoreManager.finalize_scores()
        print("BOIDS_SIMULATION_COMPLETE_SUCCESS")
        print(self.scoreManager.generate_report())
        pygame.quit()
        sys.exit(0)

# Main entry point
def main() -> None:
    parser = argparse.ArgumentParser(description="Boids++ Simulation")
    parser.add_argument("--auto-test", action="store_true", help="Run 30-second auto-test mode")
    parser.add_argument("--config", type=str, default=None, help="Path to config JSON file")
    args = parser.parse_args()

    configManager = ConfigManager(args.config)
    sim = Simulation(configManager, auto_test_mode=args.auto_test)
    try:
        sim.run()
    except Exception as e:
        print(f"Simulation terminated due to error: {e}")
    finally:
        pygame.quit()

if __name__ == "__main__":
    main()

