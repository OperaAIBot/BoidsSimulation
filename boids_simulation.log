Iteration 14
Timestamp: 2025-07-12 16:27:56
==================================================

CODE:
# filename: boids_simulation.py
import sys
import math
import time
import json
import threading
import traceback
from typing import List, Optional, Tuple, Dict, Type, Union
from collections import defaultdict, deque
import numpy as np
import pygame
import asyncio
import multiprocessing as mp
import logging
import os

# ========== Logging Setup ==========
LOG_FILENAME = "boids_simulation.log"
logging.basicConfig(
    filename=LOG_FILENAME,
    filemode='w',
    level=logging.DEBUG,
    format='%(asctime)s %(levelname)s %(message)s'
)
logger = logging.getLogger("BoidsSim")

# ========== Constants ==========
WINDOW_WIDTH = 1280
WINDOW_HEIGHT = 720
FPS_TARGET = 60
MAX_SPEED = 4.0
MAX_FORCE = 0.05
BOID_SIZE = 6
PREDATOR_SIZE = 10
OBSTACLE_SIZE = 15
LEADER_SIZE = 8

GRID_CELL_SIZE = 50  # Spatial hash cell size
NEIGHBOR_RADIUS = 75.0
PREDATOR_RADIUS = 150.0
OBSTACLE_AVOID_RADIUS = 50.0
BOUNDARY_PADDING = 25

# Color definitions
COLOR_BACKGROUND = (15, 15, 30)
COLOR_BOID = (200, 200, 255)
COLOR_PREDATOR = (255, 70, 70)
COLOR_OBSTACLE = (100, 100, 100)
COLOR_LEADER = (255, 255, 100)
COLOR_GRID = (50, 50, 80)
COLOR_TEXT = (220, 220, 220)
COLOR_STATS_BG = (0, 0, 0, 180)

# Speed multipliers for accelerated testing
DEFAULT_SPEED_MULTIPLIER = 1.0
MAX_SPEED_MULTIPLIER = 10.0

# ========== Exceptions ==========
class FeatureTestError(Exception):
    pass

class PerformanceError(Exception):
    pass

class OptimizationRequiredError(Exception):
    pass

# ========== Utility Functions ==========
def clamp(value: float, min_val: float, max_val: float) -> float:
    return max(min_val, min(value, max_val))

def limit_vector(vec: np.ndarray, max_length: float) -> np.ndarray:
    length = np.linalg.norm(vec)
    if length > max_length:
        return (vec / length) * max_length
    return vec

def vec2d(x: float, y: float) -> np.ndarray:
    return np.array([x, y], dtype=np.float32)

def distance(a: np.ndarray, b: np.ndarray) -> float:
    return np.linalg.norm(a - b)

def angle_between(v1: np.ndarray, v2: np.ndarray) -> float:
    unit_v1 = v1 / (np.linalg.norm(v1) + 1e-9)
    unit_v2 = v2 / (np.linalg.norm(v2) + 1e-9)
    dot = np.clip(np.dot(unit_v1, unit_v2), -1.0, 1.0)
    return math.acos(dot)

def random_vec2d(min_val: float, max_val: float) -> np.ndarray:
    return np.random.uniform(min_val, max_val, 2).astype(np.float32)

# ========== Configuration System ==========
class ConfigManager:
    """
    Manages loading and applying configuration presets from external JSON.
    """
    def __init__(self, config_path: str = "config.json") -> None:
        self.config_path = config_path
        self.config_data = {}
        self.load_config()

    def load_config(self) -> None:
        try:
            with open(self.config_path, "r", encoding="utf-8") as f:
                self.config_data = json.load(f)
            logger.info(f"Config loaded from {self.config_path}")
        except Exception as e:
            logger.warning(f"Failed to load config file {self.config_path}: {e}")
            self.config_data = {}

    def get_preset(self, preset_name: str) -> dict:
        return self.config_data.get("presets", {}).get(preset_name, {})

    def get_default(self) -> dict:
        return self.config_data.get("default", {})

# ========== Spatial Hash Grid ==========
class SpatialHashGrid:
    """
    Efficient spatial hash grid implementation for neighbor and collision detection.
    """
    def __init__(self, width: int, height: int, cell_size: int) -> None:
        self.width = width
        self.height = height
        self.cell_size = cell_size
        self.cols = (width // cell_size) + 2
        self.rows = (height // cell_size) + 2
        self.cells: Dict[Tuple[int, int], List['Agent']] = defaultdict(list)

    def _hash_position(self, position: np.ndarray) -> Tuple[int, int]:
        col = int(position[0] // self.cell_size)
        row = int(position[1] // self.cell_size)
        return (col, row)

    def clear(self) -> None:
        self.cells.clear()

    def insert(self, agent: 'Agent') -> None:
        cell = self._hash_position(agent.position)
        self.cells[cell].append(agent)

    def query_neighbors(self, position: np.ndarray, radius: float) -> List['Agent']:
        neighbors = []
        cell_x, cell_y = self._hash_position(position)
        radius_cells = int(math.ceil(radius / self.cell_size))
        for dx in range(-radius_cells, radius_cells + 1):
            for dy in range(-radius_cells, radius_cells + 1):
                cell = (cell_x + dx, cell_y + dy)
                for agent in self.cells.get(cell, []):
                    if agent.is_active and np.linalg.norm(agent.position - position) < radius:
                        neighbors.append(agent)
        return neighbors

    def draw_grid(self, surface: pygame.Surface) -> None:
        for col in range(self.cols):
            pygame.draw.line(surface, COLOR_GRID, (col * self.cell_size, 0), (col * self.cell_size, self.height))
        for row in range(self.rows):
            pygame.draw.line(surface, COLOR_GRID, (0, row * self.cell_size), (self.width, row * self.cell_size))

# ========== Agent Base Class ==========
class Agent:
    """
    Base class for all agents in the simulation.
    """
    def __init__(self,
                 position: np.ndarray,
                 velocity: np.ndarray,
                 max_speed: float,
                 max_force: float,
                 size: int,
                 color: Tuple[int, int, int]) -> None:
        self.position = position
        self.velocity = velocity
        self.acceleration = np.zeros(2, dtype=np.float32)
        self.max_speed = max_speed
        self.max_force = max_force
        self.size = size
        self.color = color
        self.is_active = True
        self.id = id(self)  # unique identifier for debugging
        self.type = "Agent"

    def update(self, dt: float) -> None:
        """
        Update agent position and velocity.
        """
        self.velocity += self.acceleration
        self.velocity = limit_vector(self.velocity, self.max_speed)
        self.position += self.velocity * dt
        self.acceleration *= 0.0
        self.handle_boundary()

    def apply_force(self, force: np.ndarray) -> None:
        self.acceleration += force

    def handle_boundary(self) -> None:
        """
        Wrap-around boundary handling.
        """
        x, y = self.position
        if x < 0:
            self.position[0] = WINDOW_WIDTH
        elif x > WINDOW_WIDTH:
            self.position[0] = 0
        if y < 0:
            self.position[1] = WINDOW_HEIGHT
        elif y > WINDOW_HEIGHT:
            self.position[1] = 0

    def draw(self, surface: pygame.Surface) -> None:
        """
        Draw the agent as a rotated triangle indicating velocity direction.
        """
        angle = math.atan2(self.velocity[1], self.velocity[0])
        points = [
            (self.position + self._rotate_point(vec2d(self.size, 0), angle)),
            (self.position + self._rotate_point(vec2d(-self.size * 0.6, self.size * 0.5), angle)),
            (self.position + self._rotate_point(vec2d(-self.size * 0.6, -self.size * 0.5), angle))
        ]
        pygame.draw.polygon(surface, self.color, points)

    @staticmethod
    def _rotate_point(point: np.ndarray, angle: float) -> np.ndarray:
        cos_ang = math.cos(angle)
        sin_ang = math.sin(angle)
        x = point[0] * cos_ang - point[1] * sin_ang
        y = point[0] * sin_ang + point[1] * cos_ang
        return np.array([x, y], dtype=np.float32)

# ========== Specific Agent Types ==========
class Boid(Agent):
    def __init__(self, position: np.ndarray, velocity: np.ndarray) -> None:
        super().__init__(position, velocity, max_speed=MAX_SPEED, max_force=MAX_FORCE,
                         size=BOID_SIZE, color=COLOR_BOID)
        self.type = "Boid"

class Predator(Agent):
    def __init__(self, position: np.ndarray, velocity: np.ndarray) -> None:
        super().__init__(position, velocity, max_speed=MAX_SPEED * 1.3, max_force=MAX_FORCE * 1.5,
                         size=PREDATOR_SIZE, color=COLOR_PREDATOR)
        self.type = "Predator"

class Obstacle(Agent):
    def __init__(self, position: np.ndarray) -> None:
        super().__init__(position, vec2d(0, 0), max_speed=0, max_force=0,
                         size=OBSTACLE_SIZE, color=COLOR_OBSTACLE)
        self.type = "Obstacle"

    def update(self, dt: float) -> None:
        pass  # Obstacles do not move

    def draw(self, surface: pygame.Surface) -> None:
        pygame.draw.circle(surface, self.color, self.position.astype(int), self.size)

class Leader(Boid):
    def __init__(self, position: np.ndarray, velocity: np.ndarray) -> None:
        super().__init__(position, velocity)
        self.size = LEADER_SIZE
        self.color = COLOR_LEADER
        self.type = "Leader"

# ========== Behavior and Steering ==========
class BehaviorManager:
    """
    Manages weighted steering behaviors for agents.
    """
    def __init__(self, config: dict) -> None:
        self.config = config
        self.weights = {
            "separation": self.config.get("weightSeparation", 1.5),
            "alignment": self.config.get("weightAlignment", 1.0),
            "cohesion": self.config.get("weightCohesion", 1.0),
            "obstacleAvoid": self.config.get("weightObstacleAvoid", 3.0),
            "predatorAvoid": self.config.get("weightPredatorAvoid", 5.0),
            "predatorChase": self.config.get("weightPredatorChase", 6.0),
            "leaderFollow": self.config.get("weightLeaderFollow", 1.5)
        }

    def calculate(self, agent: Agent, neighbors: List[Agent], obstacles: List[Agent],
                  predators: List[Agent], leaders: List[Agent]) -> np.ndarray:
        """
        Compute the combined steering force for the agent.
        """
        force = np.zeros(2, dtype=np.float32)
        force += self.Separation(agent, neighbors) * self.weights["separation"]
        force += self.Alignment(agent, neighbors) * self.weights["alignment"]
        force += self.Cohesion(agent, neighbors) * self.weights["cohesion"]
        force += self.ObstacleAvoidance(agent, obstacles) * self.weights["obstacleAvoid"]
        if agent.type == "Boid" or agent.type == "Leader":
            force += self.PredatorAvoid(agent, predators) * self.weights["predatorAvoid"]
            force += self.FollowLeader(agent, leaders) * self.weights["leaderFollow"]
        elif agent.type == "Predator":
            force += self.PredatorChase(agent, neighbors) * self.weights["predatorChase"]
        return limit_vector(force, agent.max_force)

    def Separation(self, agent: Agent, neighbors: List[Agent]) -> np.ndarray:
        desired_separation = BOID_SIZE * 2
        steer = np.zeros(2, dtype=np.float32)
        count = 0
        for other in neighbors:
            if other is agent:
                continue
            d = np.linalg.norm(agent.position - other.position)
            if 0 < d < desired_separation:
                diff = agent.position - other.position
                diff /= d * d
                steer += diff
                count += 1
        if count > 0:
            steer /= count
            steer = self._steer_towards(agent, steer)
        return steer

    def Alignment(self, agent: Agent, neighbors: List[Agent]) -> np.ndarray:
        neighbor_dist = NEIGHBOR_RADIUS
        sum_vel = np.zeros(2, dtype=np.float32)
        count = 0
        for other in neighbors:
            if other is agent:
                continue
            d = np.linalg.norm(agent.position - other.position)
            if d < neighbor_dist:
                sum_vel += other.velocity
                count += 1
        if count > 0:
            avg_vel = sum_vel / count
            return self._steer_towards(agent, avg_vel)
        return np.zeros(2, dtype=np.float32)

    def Cohesion(self, agent: Agent, neighbors: List[Agent]) -> np.ndarray:
        neighbor_dist = NEIGHBOR_RADIUS
        center_mass = np.zeros(2, dtype=np.float32)
        count = 0
        for other in neighbors:
            if other is agent:
                continue
            d = np.linalg.norm(agent.position - other.position)
            if d < neighbor_dist:
                center_mass += other.position
                count += 1
        if count > 0:
            center_mass /= count
            return self._steer_towards(agent, center_mass - agent.position)
        return np.zeros(2, dtype=np.float32)

    def ObstacleAvoidance(self, agent: Agent, obstacles: List[Agent]) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        for obs in obstacles:
            d = np.linalg.norm(agent.position - obs.position)
            if d < OBSTACLE_AVOID_RADIUS + obs.size:
                diff = agent.position - obs.position
                diff /= d * d
                steer += diff
        steer = limit_vector(steer, agent.max_force)
        return steer

    def PredatorAvoid(self, agent: Agent, predators: List[Agent]) -> np.ndarray:
        steer = np.zeros(2, dtype=np.float32)
        for pred in predators:
            d = np.linalg.norm(agent.position - pred.position)
            if d < PREDATOR_RADIUS:
                diff = agent.position - pred.position
                diff /= d * d
                steer += diff
        steer = limit_vector(steer, agent.max_force)
        return steer

    def PredatorChase(self, predator: Agent, prey_list: List[Agent]) -> np.ndarray:
        target = None
        min_dist = float('inf')
        for prey in prey_list:
            if prey.type in ("Boid", "Leader") and prey.is_active:
                d = np.linalg.norm(predator.position - prey.position)
                if d < min_dist and d < PREDATOR_RADIUS * 1.5:
                    min_dist = d
                    target = prey
        if target:
            desired = target.position - predator.position
            desired = desired / (np.linalg.norm(desired) + 1e-9) * predator.max_speed
            steer = desired - predator.velocity
            return limit_vector(steer, predator.max_force)
        return np.zeros(2, dtype=np.float32)

    def FollowLeader(self, agent: Agent, leaders: List[Agent]) -> np.ndarray:
        if not leaders:
            return np.zeros(2, dtype=np.float32)
        nearest_leader = None
        min_dist = float('inf')
        for leader in leaders:
            d = np.linalg.norm(agent.position - leader.position)
            if d < min_dist and d < NEIGHBOR_RADIUS * 2:
                min_dist = d
                nearest_leader = leader
        if nearest_leader:
            desired = nearest_leader.position - agent.position
            return self._steer_towards(agent, desired)
        return np.zeros(2, dtype=np.float32)

    def _steer_towards(self, agent: Agent, desired: np.ndarray) -> np.ndarray:
        desired_norm = np.linalg.norm(desired)
        if desired_norm == 0:
            return np.zeros(2, dtype=np.float32)
        desired = (desired / desired_norm) * agent.max_speed
        steer = desired - agent.velocity
        steer = limit_vector(steer, agent.max_force)
        return steer

# ========== Score Manager ==========
class ScoreManager:
    """
    Evaluates features and performance, calculates scores, and outputs report.
    """
    def __init__(self) -> None:
        self.scores = {
            "FlockingBehavior": 0,
            "SpatialHashEfficiency": 0,
            "ObstacleAvoidance": 0,
            "PredatorPreyInteractions": 0,
            "UIAndControls": 0,
            "PerformanceOptimization": 0,
            "CodeQuality": 0,
            "Documentation": 0,
            "ErrorHandling": 0,
            "Testing": 0
        }
        self.feature_weights = {
            "FlockingBehavior": 20,
            "SpatialHashEfficiency": 15,
            "ObstacleAvoidance": 10,
            "PredatorPreyInteractions": 10,
            "UIAndControls": 10,
            "PerformanceOptimization": 15,
            "CodeQuality": 10,
            "Documentation": 5,
            "ErrorHandling": 5,
            "Testing": 5
        }
        self.performance_fps = []
        self.agent_count = 0

    def record_fps(self, fps: float) -> None:
        self.performance_fps.append(fps)

    def set_agent_count(self, count: int) -> None:
        self.agent_count = count

    def evaluate_performance(self) -> None:
        if not self.performance_fps:
            self.scores["PerformanceOptimization"] = 0
            return
        avg_fps = sum(self.performance_fps) / len(self.performance_fps)
        if self.agent_count < 200:
            # Scale down performance score if agent count is less than 200
            scale_factor = self.agent_count / 200.0
        else:
            scale_factor = 1.0
        effective_fps = avg_fps * scale_factor
        if effective_fps >= 60:
            self.scores["PerformanceOptimization"] = 20
        elif effective_fps >= 45:
            self.scores["PerformanceOptimization"] = 14
        elif effective_fps >= 30:
            self.scores["PerformanceOptimization"] = 9
        else:
            self.scores["PerformanceOptimization"] = 4

    def set_feature_score(self, feature_name: str, score: int) -> None:
        if feature_name in self.scores:
            max_score = self.feature_weights.get(feature_name, 0)
            self.scores[feature_name] = clamp(score, 0, max_score)

    def total_score(self) -> int:
        return sum(self.scores.values())

    def print_report(self) -> None:
        total = self.total_score()
        print(f"BOIDS_SIMULATION_SCORE: {total}/100\n")
        print("Score Breakdown:")
        for feature, score in self.scores.items():
            max_score = self.feature_weights.get(feature, 0)
            print(f"- {feature.replace('_', ' ')}: {score}/{max_score}")
        print("\nRecommendations:")
        if self.scores["FlockingBehavior"] < 20:
            print("- Improve flocking cohesion and separation algorithms.")
        if self.scores["SpatialHashEfficiency"] < 15:
            print("- Optimize spatial hash grid cell size and lookup methods.")
        if self.scores["ObstacleAvoidance"] < 10:
            print("- Enhance obstacle detection and avoidance behaviors.")
        if self.scores["PredatorPreyInteractions"] < 10:
            print("- Refine predator chasing and prey evasion logic.")
        if self.scores["PerformanceOptimization"] < 15:
            print("- Profile and optimize bottlenecks, reduce visual complexity if needed.")

# ========== Simulation Class ==========
class BoidsSimulation:
    """
    Main simulation controller class.
    """
    def __init__(self, config: dict, auto_test: bool = False) -> None:
        self.config = config
        self.auto_test = auto_test
        self.speedMultiplier = DEFAULT_SPEED_MULTIPLIER
        self.screen = None
        self.clock = None
        self.agents: List[Agent] = []
        self.boids: List[Boid] = []
        self.predators: List[Predator] = []
        self.obstacles: List[Obstacle] = []
        self.leaders: List[Leader] = []
        self.spatialGrid = SpatialHashGrid(WINDOW_WIDTH, WINDOW_HEIGHT, GRID_CELL_SIZE)
        self.behaviorManager = BehaviorManager(self.config)
        self.running = True
        self.showGrid = False
        self.showStats = True
        self.font = None
        self.scoreManager = ScoreManager()
        self.last_fps = 0.0
        self.frame_times: deque = deque(maxlen=60)
        self.frame_count = 0
        self.start_time = time.time()
        self.test_phase_start = self.start_time
        self.test_phase = 0  # 0: flocking, 1: predator-prey, 2: obstacles
        self.test_duration = 30.0
        self.test_phase_durations = [10.0, 10.0, 10.0]
        self.agent_count_target = 250  # ~200+ agents for performance target

    def init_pygame(self) -> None:
        pygame.init()
        self.screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
        pygame.display.set_caption("Boids++ Simulation")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont("Consolas", 16, bold=True)

    def create_agents(self) -> None:
        """
        Create agents according to the test phase or config.
        """
        self.agents.clear()
        self.boids.clear()
        self.predators.clear()
        self.obstacles.clear()
        self.leaders.clear()

        if self.test_phase == 0:
            # Flocking only: Boids + Leaders
            num_boids = int(self.agent_count_target * 0.9)
            num_leaders = max(1, int(self.agent_count_target * 0.02))
            for _ in range(num_boids):
                pos = random_vec2d(0, WINDOW_WIDTH), random_vec2d(0, WINDOW_HEIGHT)
                position = vec2d(np.random.uniform(0, WINDOW_WIDTH), np.random.uniform(0, WINDOW_HEIGHT))
                velocity = random_vec2d(-1, 1)
                boid = Boid(position, velocity)
                self.boids.append(boid)
            for _ in range(num_leaders):
                position = vec2d(np.random.uniform(0, WINDOW_WIDTH), np.random.uniform(0, WINDOW_HEIGHT))
                velocity = random_vec2d(-1, 1)
                leader = Leader(position, velocity)
                self.leaders.append(leader)

        elif self.test_phase == 1:
            # Predator-prey: Boids + Predators + Leaders
            num_boids = int(self.agent_count_target * 0.7)
            num_predators = max(1, int(self.agent_count_target * 0.05))
            num_leaders = max(1, int(self.agent_count_target * 0.02))
            for _ in range(num_boids):
                position = vec2d(np.random.uniform(0, WINDOW_WIDTH), np.random.uniform(0, WINDOW_HEIGHT))
                velocity = random_vec2d(-1, 1)
                boid = Boid(position, velocity)
                self.boids.append(boid)
            for _ in range(num_predators):
                position = vec2d(np.random.uniform(0, WINDOW_WIDTH), np.random.uniform(0, WINDOW_HEIGHT))
                velocity = random_vec2d(-1, 1)
                predator = Predator(position, velocity)
                self.predators.append(predator)
            for _ in range(num_leaders):
                position = vec2d(np.random.uniform(0, WINDOW_WIDTH), np.random.uniform(0, WINDOW_HEIGHT))
                velocity = random_vec2d(-1, 1)
                leader = Leader(position, velocity)
                self.leaders.append(leader)

        else:
            # Obstacles + Boids + Predators + Leaders
            num_boids = int(self.agent_count_target * 0.6)
            num_predators = max(1, int(self.agent_count_target * 0.05))
            num_leaders = max(1, int(self.agent_count_target * 0.02))
            num_obstacles = int(self.agent_count_target * 0.1)
            for _ in range(num_boids):
                position = vec2d(np.random.uniform(0, WINDOW_WIDTH), np.random.uniform(0, WINDOW_HEIGHT))
                velocity = random_vec2d(-1, 1)
                boid = Boid(position, velocity)
                self.boids.append(boid)
            for _ in range(num_predators):
                position = vec2d(np.random.uniform(0, WINDOW_WIDTH), np.random.uniform(0, WINDOW_HEIGHT))
                velocity = random_vec2d(-1, 1)
                predator = Predator(position, velocity)
                self.predators.append(predator)
            for _ in range(num_leaders):
                position = vec2d(np.random.uniform(0, WINDOW_WIDTH), np.random.uniform(0, WINDOW_HEIGHT))
                velocity = random_vec2d(-1, 1)
                leader = Leader(position, velocity)
                self.leaders.append(leader)
            for _ in range(num_obstacles):
                position = vec2d(np.random.uniform(OBSTACLE_SIZE, WINDOW_WIDTH - OBSTACLE_SIZE),
                                 np.random.uniform(OBSTACLE_SIZE, WINDOW_HEIGHT - OBSTACLE_SIZE))
                obstacle = Obstacle(position)
                self.obstacles.append(obstacle)

        self.agents = self.boids + self.predators + self.obstacles + self.leaders
        self.scoreManager.set_agent_count(len(self.agents))

    def run(self) -> None:
        try:
            self.init_pygame()
            self.create_agents()
            last_time = time.perf_counter()
            accel_speed = 1.0 if not self.auto_test else MAX_SPEED_MULTIPLIER
            self.speedMultiplier = accel_speed

            while self.running:
                current_time = time.perf_counter()
                dt = (current_time - last_time) * self.speedMultiplier
                last_time = current_time

                self.handle_events()

                self.update_agents(dt)

                self.render()

                self.frame_count += 1
                self.frame_times.append(self.clock.get_time())
                fps = self.clock.get_fps()
                self.last_fps = fps
                self.scoreManager.record_fps(fps)

                self.clock.tick(FPS_TARGET)

                if self.auto_test:
                    self.handle_auto_test(current_time)

        except Exception as e:
            logger.error(f"Exception in simulation run: {e}\n{traceback.format_exc()}")
        finally:
            pygame.quit()
            if self.auto_test:
                print("BOIDS_SIMULATION_COMPLETE_SUCCESS")
                self.scoreManager.evaluate_performance()
                self.scoreManager.print_report()
                sys.exit(0)

    def handle_auto_test(self, current_time: float) -> None:
        elapsed = current_time - self.start_time
        # Switch test phases
        phase_time = 0
        for idx, duration in enumerate(self.test_phase_durations):
            phase_time += duration
            if elapsed < phase_time:
                if idx != self.test_phase:
                    self.test_phase = idx
                    self.create_agents()
                break
        if elapsed >= self.test_duration:
            self.running = False

    def handle_events(self) -> None:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False
                elif event.key == pygame.K_g:
                    self.showGrid = not self.showGrid
                elif event.key == pygame.K_s:
                    self.showStats = not self.showStats
                elif event.key == pygame.K_UP:
                    self.speedMultiplier = min(self.speedMultiplier + 0.5, MAX_SPEED_MULTIPLIER)
                elif event.key == pygame.K_DOWN:
                    self.speedMultiplier = max(self.speedMultiplier - 0.5, 0.1)

    def update_agents(self, dt: float) -> None:
        self.spatialGrid.clear()
        for agent in self.agents:
            self.spatialGrid.insert(agent)

        # Pre-fetch obstacle and predator lists for efficiency
        obstacles = self.obstacles
        predators = self.predators
        leaders = self.leaders

        # Process boids and leaders
        for agent in self.boids + self.leaders:
            neighbors = self.spatialGrid.query_neighbors(agent.position, NEIGHBOR_RADIUS)
            steering = self.behaviorManager.calculate(agent, neighbors, obstacles, predators, leaders)
            agent.apply_force(steering)
            agent.update(dt)

        # Process predators
        for predator in self.predators:
            neighbors = self.spatialGrid.query_neighbors(predator.position, PREDATOR_RADIUS)
            steering = self.behaviorManager.calculate(predator, neighbors, obstacles, predators, leaders)
            predator.apply_force(steering)
            predator.update(dt)

        # Obstacles do not move

    def render(self) -> None:
        self.screen.fill(COLOR_BACKGROUND)

        if self.showGrid:
            self.spatialGrid.draw_grid(self.screen)

        # Draw obstacles first
        for obstacle in self.obstacles:
            obstacle.draw(self.screen)

        # Draw agents
        for agent in self.boids + self.leaders + self.predators:
            agent.draw(self.screen)

        if self.showStats:
            self.draw_stats()

        pygame.display.flip()

    def draw_stats(self) -> None:
        fps_text = self.font.render(f"FPS: {self.last_fps:.1f}", True, COLOR_TEXT)
        agent_text = self.font.render(f"Agents: {len(self.agents)}", True, COLOR_TEXT)
        speed_text = self.font.render(f"Speed Multiplier: {self.speedMultiplier:.1f}x", True, COLOR_TEXT)
        grid_text = self.font.render(f"Grid: {'On' if self.showGrid else 'Off'} (Toggle G)", True, COLOR_TEXT)
        stats_text = self.font.render(f"Stats: {'On' if self.showStats else 'Off'} (Toggle S)", True, COLOR_TEXT)

        y = 5
        for text_surface in [fps_text, agent_text, speed_text, grid_text, stats_text]:
            self.screen.blit(text_surface, (5, y))
            y += 20

# ========== Main Entrypoint ==========
def main() -> None:
    auto_test = '--auto-test' in sys.argv
    config_manager = ConfigManager()
    config = config_manager.get_default()
    sim = BoidsSimulation(config, auto_test=auto_test)
    sim.run()

if __name__ == "__main__":
    main()

